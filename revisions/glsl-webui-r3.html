<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GLSL Image Shader</title>
        <style>
            /* ==================== CSS VARIABLES ==================== */
            :root {
                /* ==================== COLOR SCHEME ==================== */
                --background: var(--bg-dark); /* Main background */
                --bg-dark: #1e0b10;
                --bg-panel: #ff99b21f;
                --bg-console: #000000;
                --border: #ff99b21f;
                --border-input: #ff99b21f;
                --text: #ff99b2;
                --btn: #ff99b21f;
                --btn-hover: #ff99b252;
                --btn-active: #ffc2d1;
                --btn-active-text-color: #1e0b10;
                --btn-danger: #ff477552;
                --btn-danger-hover: #ff477552;
                --btn-danger-text: #ff99b2;
                --console-text: #ff99b2;
                --h1-color: #ffc2d1;
                --h2-color: #ffc2d1;
                --h3-color: #ffc2d1;
                --slider-color: var(--btn-hover);
                --btn-border-active: #ff99b2;
                --label-color: var(--text);
                --canvas-max-height: 70vh;

                /* ==================== FORM CONTROLS ==================== */
                textarea,
                input {
                    background-color: var(--bg-panel);
                    color: var(--text);
                    border: var(--border-thickness) solid var(--border-input);
                    border-radius: var(--border-radius);
                    padding: 8px;
                    width: 100%;
                    box-sizing: border-box;
                    font-family: monospace;
                    transition: border-color 0.2s ease-in-out;
                }

                textarea:focus,
                input[type="text"]:focus,
                input[type="number"]:focus,
                input[type="file"]:focus {
                    outline: none;
                    border-color: var(--btn-border-active);
                }

                label {
                    color: var(--label-color);
                }

                /* ==================== FULLSCREEN ==================== */
                --fullscreen-bg: rgba(0, 0, 0, 0.9);
                /* Using theme vars as base, but could be different if needed */
                --exit-btn-bg: var(--btn);
                --exit-btn-hover-bg: var(--btn-hover);
                --exit-btn-text: var(--text);
                --exit-btn-hover-bg: rgba(30, 30, 30, 0.8);

                /* ==================== TRANSPARENCY GRID ==================== */
                --grid-color: #ff99b21f;
                --grid-size: 16px;

                /* ==================== SPACING & SIZING ==================== */
                --gap: 16px;
                --border-thickness: 2px;
                --border-radius: 8px;
                --margin: 16px;
                --margin-small: 8px;
                --button-margin: 4px 0 4px 0;
                --padding: 16px;
                --padding-small: 8px;
                --console-padding: var(--padding);

                /* ==================== TYPOGRAPHY ==================== */
                --font-family: sans-serif;
                --console-font-size: 1em;
            }

            /* ==================== BASE STYLES ==================== */
            body {
                background-color: var(--background);
                color: var(--text);
                font-family: var(--font-family);
                margin: var(--padding);
            }

            h1 {
                position: center;
                text-align: center;
            }

            h2,
            h3 {
                margin: var(--margin) 0 var(--margin) 0;
            }

            /* ==================== LAYOUT STRUCTURE ==================== */
            .container {
                display: flex;
                flex-direction: column;
                gap: var(--gap);
            }

            .row {
                display: flex;
                gap: var(--gap);
                flex-wrap: wrap;
            }

            .col {
                flex: 1;
                min-width: 300px;
            }

            /* ==================== CANVAS & PREVIEW ==================== */
            .canvas-container {
                max-width: 100%;
                background-color: var(--bg-panel);
                border: none;
                position: relative;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
                margin: 0 auto;
                width: fit-content;
                padding: 0;
            }

            .canvas-container.transparent {
                background-image:
                    linear-gradient(
                        45deg,
                        var(--grid-color) 25%,
                        transparent 25%
                    ),
                    linear-gradient(
                        -45deg,
                        var(--grid-color) 25%,
                        transparent 25%
                    ),
                    linear-gradient(
                        45deg,
                        transparent 75%,
                        var(--grid-color) 75%
                    ),
                    linear-gradient(
                        -45deg,
                        transparent 75%,
                        var(--grid-color) 75%
                    );
                background-size: var(--grid-size) var(--grid-size);
                background-position:
                    0 0,
                    0 10px,
                    10px -10px,
                    -10px 0px;
            }

            canvas {
                background-color: transparent;
                border: none;
                display: block;
                max-width: 100%;
                width: auto;
                height: auto;
                margin: 0;
                object-fit: contain;
                image-rendering: -moz-crisp-edges;
                image-rendering: -webkit-optimize-contrast;
                image-rendering: crisp-edges;
                -ms-interpolation-mode: nearest-neighbor;
            }

            /* ==================== FORM CONTROLS ==================== */
            textarea,
            input {
                background-color: var(--bg-panel);
                color: var(--text);
                border: var(--border-thickness) solid var(--border-input);
                border-radius: var(--border-radius);
                padding: 8px;
                width: 100%;
                box-sizing: border-box;
                font-family: monospace;
            }

            label {
                color: var(--label-color);
            }

            /* ==================== CODE EDITOR ==================== */
            .code-editor {
                height: 400px;
                background-color: var(--bg-panel);
                border: var(--border-thickness) solid var(--border-input); /* Existing border */
                border-radius: var(--border-radius);
                overflow: hidden;
                transition: border-color 0.2s ease-in-out;
            }

            .code-editor:focus-within {
                border-color: var(
                    --btn-border-active
                ); /* Highlight border when textarea inside is focused */
            }

            .code-editor textarea {
                width: 100%;
                height: 100%;
                resize: none;
                border: none; /* Textarea itself has no border */
                padding: 8px;
                background-color: transparent;
                line-height: 1.5;
                tab-size: 2;
                font-family: monospace;
                color: var(--text);
                outline: none; /* Remove focus outline from the textarea itself */
            }

            /* ==================== BUTTONS ==================== */
            button {
                background-color: var(--btn);
                color: var(--text);
                border: none;
                padding: 8px 16px;
                cursor: pointer;
                margin: 5px 0;
                border-radius: var(--border-radius);
                transition: all 0.2s ease;
            }

            button:hover {
                background-color: var(--btn-hover);
            }

            button.highlight-border {
                border: var(--border-thickness) solid var(--btn-border-active);
            }

            button:active {
                transform: scale(0.98);
            }

            button.active {
                background-color: var(--btn-active);
                color: var(--btn-active-text-color);
            }

            button.danger {
                background-color: var(--btn);
                color: var(--btn-danger-text);
            }

            button.danger:hover {
                background-color: var(--btn-danger-hover);
            }

            button.border-active {
                border: var(--border-thickness) solid var(--btn-border-active);
            }

            /* ==================== CONSOLE ==================== */
            .console {
                background-color: var(--bg-console);
                color: var(--console-text);
                padding: var(--console-padding);
                font-family: monospace;
                font-size: var(--console-font-size);
                height: 150px;
                overflow-y: auto;
                margin-top: 10px;
                white-space: pre-wrap;
                border-radius: var(--border-radius);
            }

            /* ==================== CONTROL SECTIONS ==================== */
            .control-section {
                background-color: var(--bg-panel);
                padding: var(--padding-small) var(--padding) var(--padding)
                    var(--padding);
                border-radius: var(--border-radius);
                margin: var(--margin) 0 0 0;
            }

            .output-actions {
                display: flex;
                align-items: center;
                gap: var(--gap);
                flex-wrap: wrap;
                border: var(--border-thickness);
                border-style: solid;
                border-color: var(--border);
                padding: var(--padding-small);
                border-radius: var(--border-radius);
                margin: var(--margin) 0 0 0;
            }

            .transform-controls {
                margin: var(--margin) 0;
                padding: var(--padding);
                background-color: var(--bg-panel);
                border-radius: var(--border-radius);
            }

            /* ==================== VARIABLE ROWS ==================== */
            .var-row {
                display: flex;
                align-items: center;
                gap: var(--gap);
                flex-wrap: wrap;
                border-color: var(--border);
                border-radius: var(--border-radius);
                margin: var(--margin) 0 0 0;
            }

            .var-name {
                width: 150px;
                flex-shrink: 0;
            }

            .var-input {
                flex: 1;
                margin: 4px 0 4px 0;
            }

            .external-image-row {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            /* ==================== SAVE SLOTS ==================== */
            .save-slots {
                display: flex;
                flex-wrap: wrap;
                gap: 8px; /* Slightly smaller gap might look better */
                margin: var(--margin) 0;
            }

            .save-slot {
                background-color: var(--btn);
                padding: 8px;
                border-radius: var(--border-radius);
                cursor: pointer;
                flex: 1;
                min-width: 80px;
                text-align: center;
                transition: all 0.2s ease;
            }

            .save-slot:hover {
                background-color: var(--btn-hover);
            }

            .save-slot:active {
                transform: scale(0.98);
            }

            /* Active state only applies to save slots */
            .save-slot.active {
                background-color: var(--btn-active);
                color: var(--btn-active-text-color); /* Was var(--background) */
            }

            @media (max-width: 768px) {
                .save-slots {
                    gap: 5px; /* Even smaller gap on mobile */
                }

                .save-slot {
                    min-width: 60px; /* Adjust min-width for all */
                    padding: 6px; /* Adjust padding for all */
                    font-size: 0.9em; /* Adjust font size for all */
                }
            }
            /* ==================== CHECKBOXES ==================== */
            .checkbox-wrapper {
                display: flex;
                align-items: center;
                gap: 8px;
                white-space: nowrap;
                margin-right: 15px;
            }

            input[type="checkbox"] {
                appearance: none;
                -webkit-appearance: none;
                width: var(--checkbox-size);
                height: var(--checkbox-size);
                border: var(--border-thickness) solid var(--checkbox-border);
                background-color: var(--bg-panel);
                border-radius: 4px;
                position: relative;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }

            input[type="checkbox"]:hover {
                background-color: var(--checkbox-hover);
            }

            input[type="checkbox"]:checked {
                background-color: var(--btn-active);
            }

            /* ==================== NUMBER INPUTS ==================== */
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            input[type="number"] {
                -moz-appearance: textfield;
            }

            /* ==================== RANGE INPUTS ==================== */
            input[type="range"] {
                accent-color: var(--slider-color);
            }

            /* ==================== FULLSCREEN PREVIEW ==================== */
            .fullscreen-preview {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: var(--fullscreen-bg);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                cursor: pointer;
            }

            .fullscreen-preview canvas {
                max-width: 95vw;
                max-height: 95vh;
                object-fit: contain;
            }

            .exit-fullscreen {
                position: absolute;
                top: var(--padding); /* Use theme padding for top spacing */
                right: var(--padding); /* Use theme padding for right spacing */
                background: var(--btn); /* Use standard button background */
                color: var(--text); /* Use standard button text color */
                border: none;
                border-radius: var(
                    --border-radius
                ); /* Keep consistent radius */
                padding: 8px 16px; /* Use standard button padding */
                cursor: pointer;
                transition: all 0.2s ease; /* Add standard transition */
            }

            .exit-fullscreen:hover {
                background: var(--btn-hover); /* Use standard button hover */
            }

            .exit-fullscreen:active {
                transform: scale(0.98); /* Standard active effect */
                background: var(--btn-active); /* Use standard button active */
            }

            /* Remove the inline style from the HTML for #fullscreenPauseTime */
            #fullscreenPauseTime {
                /* Adjust right position. This is an estimate, may need tweaking. */
                /* It assumes the first button is roughly 180px wide + theme gap */
                right: calc(var(--padding) + 180px + var(--gap));
            }

            /* ==================== DRAG & DROP ==================== */
            .canvas-container.drag-over {
                border: 2px dashed var(--btn-active) !important;
                background-color: var(--btn-hover) !important;
            }

            @media (max-width: 768px) {
                /* Reduce overall padding/margins for smaller screens */
                :root {
                    --padding: 12px;
                    --padding-small: 6px;
                    --margin: 12px;
                    --margin-small: 6px;
                    --gap: 12px;
                }

                body {
                    margin: var(
                        --padding-small
                    ); /* Reduce body margin */
                    font-size: 14px; /* Slightly smaller base font */
                }

                h1 {
                    font-size: 1.5em; /* Smaller main heading */
                }

                h2,
                h3 {
                    font-size: 1.2em; /* Smaller section headings */
                }

                /* Stack the main input and output columns */
                .row {
                    flex-direction: column;
                }

                /* Allow columns to take full width when stacked */
                .col {
                    min-width: 100%; /* Override min-width */
                    width: 100%;
                }

                /* Adjust variable rows for better wrapping */
                .var-row {
                    /* Allow items to wrap more freely */
                }

                .var-name {
                    width: 100%; /* Let label take full width */
                    margin-bottom: var(
                        --margin-small
                    ); /* Add space below label when it wraps */
                    text-align: left; /* Ensure alignment */
                    flex-shrink: 1; /* Allow shrinking if needed */
                }

                .var-input {
                    min-width: 150px; /* Ensure input has some minimum space */
                    flex-grow: 1; /* Allow input to grow */
                }

                /* Specific adjustments for multi-input rows */
                .transform-controls .var-row input[type="number"],
                .external-image-row .var-input {
                    /* Allow multiple inputs per row to share space better */
                    flex-basis: 45%; /* Roughly two inputs per line before wrapping */
                    flex-grow: 1;
                }

                /* Reduce height of code editor and console */
                .code-editor {
                    height: 250px; /* Less vertical space */
                }

                .console {
                    height: 100px; /* Less vertical space */
                }

                /* Ensure canvas container doesn't overflow */
                .canvas-container {
                    max-width: 100%;
                    /* Consider adding overflow-x: auto; if needed, but max-width should suffice */
                }

                /* Adjust button sizes/padding if necessary (optional) */
                button {
                    padding: 6px 12px; /* Slightly smaller padding */
                    font-size: 0.9em;
                }

                /* Adjust save slots */
                .save-slot {
                    min-width: 60px; /* Smaller minimum width */
                    padding: 6px;
                }

                /* Fullscreen button adjustments (optional) */
                .exit-fullscreen {
                    padding: 6px 10px;
                    font-size: 0.85em;
                    /* Recalculate position for the second button if needed */
                    /* This might require JavaScript if width is dynamic, or simpler fixed pos */
                }
                #fullscreenPauseTime {
                     /* Simple fixed position might be easier for mobile */
                     right: auto;
                     left: var(--padding);
                     /* Or adjust the complex calc if you prefer */
                     /* right: calc(var(--padding) + 120px + var(--gap)); */ /* Example adjustment */
                }

            } /* End of @media (max-width: 768px) */

            /* Optional: Add styles for even smaller screens if needed */
            /*
            @media (max-width: 480px) {
                :root {
                    --padding: 8px;
                    --gap: 8px;
                }
                body {
                    font-size: 13px;
                }
                /* Further adjustments for very small screens */
            }
            */
        </style>
    </head>
    <body>
        <!-- ==================== MAIN LAYOUT ==================== -->
        <div class="container">
            <h1>GLSL Image Shader</h1>
            <div class="row">
                <!-- ==================== INPUT COLUMN ==================== -->
                <div class="col">
                    <h2>Input</h2>

                    <!-- Image Loading Controls -->
                    <div>
                        <button id="loadImage">Load Image</button>
                        <button
                            id="unloadImage"
                            type="button"
                            style="display: none"
                        >
                            Unload Image
                        </button>
                        <input
                            type="file"
                            id="imageInput"
                            accept="image/*"
                            style="display: none"
                        />
                    </div>

                    <!-- External Image URL Input -->
                    <div class="external-image-row var-row">
                        <input
                            type="text"
                            id="externalImageUrl"
                            placeholder="Enter external image URL"
                            class="var-input"
                        />
                        <button
                            id="loadImageByUrl"
                            type="button"
                            style="display: none"
                        >
                            Load External Image
                        </button>
                        <button
                            id="clearExternalUrl"
                            type="button"
                            style="display: none"
                            class="danger"
                        >
                            Clear Link
                        </button>
                    </div>

                    <!-- Shader Controls -->
                    <h3>Shader Code</h3>
                    <div class="var-row">
                        <button id="updateShader" type="button">
                            Apply/Update Shader
                        </button>
                        <button id="toggleShader" type="button">
                            Toggle Shader
                        </button>
                        <button id="loadShader">Load Shader</button>
                        <button id="saveCurrentSlot">Save Current Slot</button>
                        <button
                            id="unloadSlot"
                            type="button"
                            style="display: none"
                        >
                            Unload Active Slot
                        </button>
                        <button id="pauseTime">Pause Time</button>
                        <div class="history-controls">
                            <button id="undoButton" title="Undo">↩</button>
                            <button id="redoButton" title="Redo">↪</button>
                        </div>
                        <input
                            type="file"
                            id="shaderInput"
                            accept=".glsl,.frag,.txt"
                            style="display: none"
                        />
                    </div>

                    <!-- Save Slots -->
                    <div class="save-slots">
                        <div class="save-slot" data-slot="1">Slot 1</div>
                        <div class="save-slot" data-slot="2">Slot 2</div>
                        <div class="save-slot" data-slot="3">Slot 3</div>
                        <div class="save-slot" data-slot="4">Slot 4</div>
                        <div class="save-slot" data-slot="5">Slot 5</div>
                    </div>

                    <!-- Shader Code Editor -->
                    <div class="code-editor">
                        <textarea
                            id="shaderCode"
                            placeholder="Enter GLSL shader code here..."
                        ></textarea>
                    </div>

                    <!-- Canvas Settings -->
                    <div class="control-section">
                        <h3>Canvas Settings</h3>
                        <div class="var-row">
                            <span class="var-name">Background:</span>
                            <input
                                type="text"
                                id="canvasBackground"
                                value="#000000"
                                class="var-input"
                                placeholder="Hex color e.g. #000000"
                            />
                            <div
                                class="color-preview"
                                id="bgColorPreview"
                                style="background-color: #000000"
                            ></div>
                            <button id="applyBackground">Apply</button>
                        </div>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input
                                    type="checkbox"
                                    id="transparentCanvas"
                                    checked
                                />
                                <label for="transparentCanvas"
                                    >Transparent Canvas</label
                                >
                            </div>
                        </div>
                        <div class="var-row">
                            <div class="var-row">
                                <span class="var-name">Zoom:</span>
                                <input
                                    type="number"
                                    id="zoomInput"
                                    value="1"
                                    min="0.1"
                                    max="5"
                                    step="0.1"
                                    style="width: 60px"
                                />
                                <button id="resetZoom">Reset</button>
                            </div>
                        </div>
                    </div>

                    <!-- Transform Controls -->
                    <div class="transform-controls">
                        <h3>Transform</h3>
                        <div class="var-row">
                            <span class="var-name">Canvas Position:</span>
                            <input
                                type="number"
                                id="canvasX"
                                placeholder="X"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasY"
                                placeholder="Y"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasWidth"
                                placeholder="Width"
                                min="1"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasHeight"
                                placeholder="Height"
                                min="1"
                                class="var-input"
                            />
                            <button id="resetCanvas">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Aspect Ratio:</span>
                            <input
                                type="number"
                                id="aspectW"
                                placeholder="Width"
                                min="1"
                                value="16"
                                class="var-input"
                            />
                            <span>:</span>
                            <input
                                type="number"
                                id="aspectH"
                                placeholder="Height"
                                min="1"
                                value="9"
                                class="var-input"
                            />
                            <button id="applyAspect">Apply</button>
                            <button id="resetAspect">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Rotation:</span>
                            <div class="rotation-presets">
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="0"
                                >
                                    0°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="90"
                                >
                                    90°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="180"
                                >
                                    180°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="270"
                                >
                                    270°
                                </button>
                            </div>
                            <button id="resetRotation">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Mirror:</span>
                            <button id="mirrorX">X</button>
                            <button id="mirrorY">Y</button>
                            <button id="resetMirror">Reset</button>
                        </div>
                    </div>
                </div>

                <!-- ==================== OUTPUT COLUMN ==================== -->
                <div class="col">
                    <h2>Output</h2>
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="canvas"></canvas>
                    </div>

                    <div class="output-actions">
                        <button id="fullscreenPreview">
                            Full Screen Preview
                        </button>
                        <button id="resetAllParams" class="danger">
                            Reset All Parameters
                        </button>
                    </div>

                    <!-- Export Image Controls -->
                    <div class="control-section">
                        <h3>Export Image</h3>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="exportWithAlpha" />
                                <label for="exportWithAlpha"
                                    >Export with Alpha</label
                                >
                            </div>
                        </div>
                        <div class="var-row">
                            <button id="savePNG">Save as PNG</button>
                            <button id="saveJPG">Save as JPG</button>
                        </div>
                    </div>

                    <!-- Export Animation Controls -->
                    <div class="control-section">
                        <h3>Export Animation</h3>
                        <div class="var-row">
                            <span class="var-name">FPS:</span>
                            <input
                                type="number"
                                id="exportFps"
                                min="1"
                                max="60"
                                value="30"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Bitrate (Mbps):</span>
                            <input
                                type="number"
                                id="exportBitrate"
                                min="1"
                                max="50"
                                value="5"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Duration (sec):</span>
                            <input
                                type="number"
                                id="animationDuration"
                                min="1"
                                value="5"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Start Time (sec):</span>
                            <input
                                type="number"
                                id="exportStartTime"
                                min="0"
                                value="0"
                                step="1"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <button id="exportMp4">Export as WebM</button>
                        </div>
                    </div>

                    <!-- Console Output -->
                    <h3>Console</h3>
                    <div id="console" class="console"></div>
                </div>
            </div>
        </div>

        <!-- ==================== FULLSCREEN PREVIEW ==================== -->
        <div
            id="fullscreenContainer"
            style="display: none"
            class="fullscreen-preview"
        >
            <canvas id="fullscreenCanvas"></canvas>
            <button class="exit-fullscreen">Exit Full Screen (ESC)</button>
            <button id="fullscreenPauseTime" class="exit-fullscreen">
                Pause Animation
            </button>
        </div>

        <!-- ==================== SHADER TEMPLATES ==================== -->
        <script type="x-shader/x-fragment" id="defaultFragmentShader">
            precision mediump float;
            varying vec2 v_texcoord;
            uniform sampler2D tex;
            uniform float time;
            void main() {
              vec4 color = texture2D(tex, v_texcoord);
              gl_FragColor = color;
            }
        </script>
        <script type="x-shader/x-vertex" id="vertexShader">
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
              gl_Position = vec4(a_position, 0.0, 1.0);
              v_texcoord = a_texcoord;
            }
        </script>

        <!-- ==================== MAIN APPLICATION SCRIPT ==================== -->
        <script>
            // ==================== GLOBAL STATE ====================
            const $ = document.getElementById.bind(document);
            const canvas = $("canvas");
            const fsCanvas = $("fullscreenCanvas");
            const canvasContainer = $("canvasContainer");
            const fsContainer = $("fullscreenContainer");
            const gl = canvas.getContext("webgl");
            let fsGl = null;
            const consoleEl = $("console");
            const codeTextarea = $("shaderCode");

            // UI Elements
            const zoomInput = $("zoomInput");
            const bgColorInput = $("canvasBackground");
            const bgColorPreview = $("bgColorPreview");
            const transCanvas = $("transparentCanvas");
            const exportAlpha = $("exportWithAlpha");
            const externalImageUrl = $("externalImageUrl");
            const loadImageByUrl = $("loadImageByUrl");
            const clearExternalUrl = $("clearExternalUrl");

            // Application State
            let image = null,
                imageTexture = null,
                program = null;
            let startTime = Date.now(),
                pausedTime = null;
            let animFrame = null,
                fsAnimFrame = null;
            let posBuffer = null,
                texCoordBuffer = null;
            let timePaused = false,
                fsTimePaused = false;
            let shaderActive = true; // Flag for shader state

            // Transform State
            let rotation = 0,
                mirrorX = false,
                mirrorY = false;
            let canvasState = { x: 0, y: 0, width: 0, height: 0 };
            let zoomLevel = 1,
                bgColor = "#000000";
            let useTransparent = true,
                useExportAlpha = false;

            // History State
            const maxHistory = 50;
            let history = [],
                historyIndex = -1;

            // ==================== UTILITY FUNCTIONS ====================

            /**
             * Logs messages to both browser console and application console
             * @param {string} message - The message to log
             * @param {string} type - The type of message (info, error, etc.)
             */
            function log(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                const formatted = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

                console[type === "error" ? "error" : "log"](message);
                consoleEl.innerHTML += formatted + "\n";
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }

            /**
             * Creates and compiles a shader
             * @param {WebGLRenderingContext} ctx - WebGL context
             * @param {number} type - Shader type (VERTEX_SHADER or FRAGMENT_SHADER)
             * @param {string} source - Shader source code
             * @returns {WebGLShader|null} Compiled shader or null on failure
             */
            function createShader(ctx, type, source) {
                const shader = ctx.createShader(type);
                ctx.shaderSource(shader, source);
                ctx.compileShader(shader);

                if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
                    log(
                        `Error compiling shader: ${ctx.getShaderInfoLog(shader)}`,
                        "error",
                    );
                    ctx.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            /**
             * Creates and links a WebGL program
             * @param {WebGLRenderingContext} ctx - WebGL context
             * @param {WebGLShader} vertexShader - Compiled vertex shader
             * @param {WebGLShader} fragmentShader - Compiled fragment shader
             * @returns {WebGLProgram|null} Linked program or null on failure
             */
            function createProgram(ctx, vertexShader, fragmentShader) {
                const prog = ctx.createProgram();
                ctx.attachShader(prog, vertexShader);
                ctx.attachShader(prog, fragmentShader);
                ctx.linkProgram(prog);

                if (!ctx.getProgramParameter(prog, ctx.LINK_STATUS)) {
                    log(
                        `Error linking program: ${ctx.getProgramInfoLog(prog)}`,
                        "error",
                    );
                    ctx.deleteProgram(prog);
                    return null;
                }

                return prog;
            }

            // ==================== IMAGE HANDLING ====================

            /**
             * Updates the state of image load buttons based on whether an image is loaded
             */
            function updateImageButtons() {
                const loadImageBtn = $("loadImage");
                const unloadImageBtn = $("unloadImage");

                if (!image) {
                    // No image loaded
                    loadImageBtn.textContent = "Load Image";
                    // Use the correct class name 'active'
                    loadImageBtn.classList.add("active"); // <-- FIX
                    unloadImageBtn.style.display = "none";
                } else {
                    // Image loaded
                    loadImageBtn.textContent = "Load New Image";
                    // Use the correct class name 'active'
                    loadImageBtn.classList.remove("active"); // <-- FIX
                    unloadImageBtn.style.display = "inline-block";
                }
            }

            /**
             * Creates a WebGL texture from the loaded image
             */
            function createImageTexture() {
                if (!image) return;

                if (imageTexture) gl.deleteTexture(imageTexture);

                imageTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                // Set texture parameters
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_WRAP_S,
                    gl.CLAMP_TO_EDGE,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_WRAP_T,
                    gl.CLAMP_TO_EDGE,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    gl.LINEAR,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    gl.LINEAR,
                );

                // Upload image to texture
                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image,
                );

                // Update canvas dimensions
                canvas.width = image.width;
                canvas.height = image.height;

                // Reset canvas state
                canvasState = {
                    x: 0,
                    y: 0,
                    width: image.width,
                    height: image.height,
                };
            }

            /**
             * Handles image file loading
             * @param {File} file - Image file to load
             */
            function handleImageFile(file) {
                if (!file.type.match("image.*")) {
                    log("Dropped file is not an image", "error");
                    return;
                }

                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        image = img;
                        canvas.width = img.width;
                        canvas.height = img.height;

                        canvasState = {
                            x: 0,
                            y: 0,
                            width: img.width,
                            height: img.height,
                        };

                        updateCanvasUI();
                        log(
                            `Image loaded: ${file.name} (${img.width}x${img.height})`,
                        );

                        createImageTexture();
                        initBuffers();
                        updateCanvasDisplay();
                        startRendering();
                        saveToHistory();
                        updateImageButtons();
                    };
                    img.src = e.target.result;
                };
                reader.readAsDataURL(file);
            }

            // ==================== SHADER COMPILATION ====================

            /**
             * Compiles the default pass-through shader
             */
            function compileDefaultShader() {
                const vertexSource = $("vertexShader").textContent;
                const defaultFragmentSource = $(
                    "defaultFragmentShader",
                ).textContent;
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    vertexSource,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    defaultFragmentSource,
                );

                const newProgram = createProgram(
                    gl,
                    vertexShader,
                    fragmentShader,
                );
                if (!newProgram) return;

                // Replace current program
                if (program) gl.deleteProgram(program);
                program = newProgram;
                gl.useProgram(program);
                log("Default shader compiled successfully");

                // Default shader wasn't explicitly compiled via Apply button
                lastCompiledCode = null;
            }

            /**
             * Compiles the custom shader from the textarea
             */
            function compileShader() {
                const fragmentSource = codeTextarea.value.trim();
                if (!fragmentSource) {
                    log("Shader code is empty!", "error");
                    return;
                }

                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    $("vertexShader").textContent,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    fragmentSource,
                );
                if (!fragmentShader) {
                    return;
                }

                const newProgram = createProgram(
                    gl,
                    vertexShader,
                    fragmentShader,
                );
                if (!newProgram) {
                    return;
                }

                if (program) gl.deleteProgram(program);
                program = newProgram;
                gl.useProgram(program);

                log("Shader compiled successfully");

                // Always update border state after any compile attempt

                // Reset time tracking
                startTime = Date.now();
                pausedTime = null;
                timePaused = false;
                $("pauseTime").classList.remove("active");
                $("pauseTime").textContent = "Pause Time";
            }

            // ==================== RENDERING ====================

            /**
             * Initializes WebGL buffers
             */
            function initBuffers() {
                // Position buffer (full-screen quad)
                posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                    gl.STATIC_DRAW,
                );

                // Texture coordinate buffer
                texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]),
                    gl.STATIC_DRAW,
                );
            }

            /**
             * Gets transformed texture coordinates based on current rotation and mirroring
             * @returns {Array} Array of texture coordinates
             */
            function getTransformedTexCoords() {
                let texCoords;
                switch (rotation % 360) {
                    case 0:
                        texCoords = [0, 1, 1, 1, 0, 0, 1, 0];
                        break;
                    case 90:
                        texCoords = [0, 0, 0, 1, 1, 0, 1, 1];
                        break;
                    case 180:
                        texCoords = [1, 0, 0, 0, 1, 1, 0, 1];
                        break;
                    case 270:
                        texCoords = [1, 1, 1, 0, 0, 1, 0, 0];
                        break;
                    default:
                        texCoords = [0, 1, 1, 1, 0, 0, 1, 0];
                }

                // Apply mirroring
                if (mirrorX) {
                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }
                if (mirrorY) {
                    for (let i = 1; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }

                // Apply canvas transformations
                if (image && image.width > 0 && image.height > 0) {
                    const xScale = canvasState.width / image.width;
                    const yScale = canvasState.height / image.height;
                    const xOffset = canvasState.x / image.width;
                    const yOffset = canvasState.y / image.height;

                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = texCoords[i] * xScale + xOffset;
                        texCoords[i + 1] = texCoords[i + 1] * yScale + yOffset;
                    }
                }
                return texCoords;
            }

            /**
             * Updates the canvas transform based on current state
             */
            function updateTransform() {
                if (!image) return;

                // Handle rotation
                if (rotation % 180 === 90) {
                    canvas.width = canvasState.height;
                    canvas.height = canvasState.width;
                } else {
                    canvas.width = canvasState.width;
                    canvas.height = canvasState.height;
                }

                // Update texture coordinates
                const texCoords = getTransformedTexCoords();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(texCoords),
                    gl.STATIC_DRAW,
                );

                // Update UI
                $("mirrorX").classList.toggle("active", mirrorX);
                $("mirrorY").classList.toggle("active", mirrorY);

                updateCanvasDisplay();
                render();
                log(
                    `Transform updated: rotation=${rotation}°, mirrorX=${mirrorX}, mirrorY=${mirrorY}, canvas=(${canvasState.x},${canvasState.y},${canvasState.width},${canvasState.height})`,
                );
            }

            /**
             * Updates the canvas display properties (background, zoom, etc.)
             */
            function updateCanvasDisplay() {
                if (useTransparent) {
                    // Get computed styles from the root element where variables are defined
                    const rootStyle = getComputedStyle(
                        document.documentElement,
                    );
                    // Read the --grid-color variable, provide a fallback if not found
                    const gridColor =
                        rootStyle.getPropertyValue("--grid-color").trim() ||
                        "#cccccc";
                    // Read the --grid-size variable, provide a fallback if not found
                    const gridSize =
                        rootStyle.getPropertyValue("--grid-size").trim() ||
                        "20px";
                    // Calculate half the grid size for positioning
                    const gridSizeValue = parseInt(gridSize); // Get numeric value (e.g., 20)
                    const halfGridSizeValue = gridSizeValue / 2; // e.g., 10

                    // Set background color to transparent
                    canvasContainer.style.backgroundColor = "transparent";

                    // Construct the background-image string using the gridColor variable
                    canvasContainer.style.backgroundImage = `
                        linear-gradient(45deg, ${gridColor} 25%, transparent 25%),
                        linear-gradient(-45deg, ${gridColor} 25%, transparent 25%),
                        linear-gradient(45deg, transparent 75%, ${gridColor} 75%),
                        linear-gradient(-45deg, transparent 75%, ${gridColor} 75%)
                    `;

                    // Set the background-size using the gridSize variable
                    canvasContainer.style.backgroundSize = `${gridSize} ${gridSize}`;

                    // Set the background-position using the calculated half size
                    // Note: We construct the pixel values (e.g., "10px")
                    canvasContainer.style.backgroundPosition = `
                        0 0,
                        0 ${halfGridSizeValue}px,
                        ${halfGridSizeValue}px ${-halfGridSizeValue}px,
                        ${-halfGridSizeValue}px 0px
                    `;
                } else {
                    // Solid background
                    canvasContainer.style.backgroundColor = bgColor;
                    canvasContainer.style.backgroundImage = "none";
                    //Reset size/position when not transparent ---
                    // Explicitly clear size and position that might have been set
                    // by the transparent state to avoid potential conflicts.
                    canvasContainer.style.backgroundSize = "";
                    canvasContainer.style.backgroundPosition = "";
                }

                // Apply zoom (This part remains the same)
                canvas.style.transformOrigin = "center center";
                canvas.style.transform = `scale(${zoomLevel})`;
            }

            /**
             * Starts the rendering loop
             */
            function startRendering() {
                if (animFrame) cancelAnimationFrame(animFrame);
                function animate() {
                    render();
                    animFrame = requestAnimationFrame(animate);
                }
                animate();
            }

            /**
             * Stops the rendering loop
             */
            function stopRendering() {
                if (animFrame) {
                    cancelAnimationFrame(animFrame);
                    animFrame = null;
                }
            }

            /**
             * Renders the current frame
             */
            function render() {
                if (!gl || !program || !imageTexture) return;

                // Set viewport to match canvas size
                gl.viewport(0, 0, canvas.width, canvas.height);

                // Set clear color based on background settings
                let r = 0,
                    g = 0,
                    b = 0,
                    a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }
                gl.clearColor(r, g, b, a);
                gl.clear(gl.COLOR_BUFFER_BIT);

                // Set up shader program
                gl.useProgram(program);

                // Set up position attribute
                const posLoc = gl.getAttribLocation(program, "a_position");
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                // Set up texture coordinate attribute
                const texLoc = gl.getAttribLocation(program, "a_texcoord");
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

                // Set up texture
                const texLocation = gl.getUniformLocation(program, "tex");
                gl.uniform1i(texLocation, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                // Set time uniform if shader uses it
                const timeLoc = gl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (timePaused && pausedTime !== null) {
                        gl.uniform1f(timeLoc, pausedTime);
                    } else {
                        gl.uniform1f(
                            timeLoc,
                            (Date.now() - startTime) / 1000.0,
                        );
                    }
                }

                // Set blending for transparent backgrounds
                if (useTransparent) {
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.disable(gl.BLEND);
                }

                // Draw the quad
                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            // ==================== EXPORT FUNCTIONS ====================

            /**
             * Saves the current canvas as an image
             * @param {string} type - Image type ('png' or 'jpeg')
             */
            function saveImage(type) {
                if (!canvas) return;
                try {
                    // Ensure rendering is complete
                    render();
                    gl.finish();

                    const mimeType =
                        type === "png" ? "image/png" : "image/jpeg";
                    const quality = type === "png" ? undefined : 0.9;

                    // Create temporary canvas for export
                    const tempCanvas = document.createElement("canvas");
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext("2d", {
                        alpha: useExportAlpha,
                    });

                    // Fill background if not exporting with alpha
                    if (!useExportAlpha) {
                        tempCtx.fillStyle = bgColor;
                        tempCtx.fillRect(
                            0,
                            0,
                            tempCanvas.width,
                            tempCanvas.height,
                        );
                    }

                    // Draw WebGL canvas to 2D canvas
                    tempCtx.drawImage(canvas, 0, 0);

                    // Create download link
                    const imageData = tempCanvas.toDataURL(mimeType, quality);
                    const link = document.createElement("a");
                    link.download = `shader_output.${type === "png" ? "png" : "jpg"}`;
                    link.href = imageData;
                    link.click();

                    log(`Image saved as ${type.toUpperCase()}`);
                } catch (error) {
                    log(`Error saving image: ${error}`, "error");
                }
            }

            /**
             * Exports an animation as WebM video
             * @param {string} type - Currently only 'webm' is supported
             */
            function exportAnimation(type) {
                if (!canvas) {
                    log("No canvas to export!", "error");
                    return;
                }

                if (type === "webm") {
                    try {
                        // Get export settings from UI
                        const duration =
                            parseFloat($("animationDuration").value) || 5;
                        const fps = parseInt($("exportFps").value) || 30;
                        const startTime =
                            parseFloat($("exportStartTime").value) || 0;
                        const bitrate = parseInt($("exportBitrate").value) || 5;

                        log(
                            `Starting animation export: ${duration * fps} frames at ${fps} fps, starting at ${startTime}s...`,
                        );

                        // Pause time for consistent export
                        timePaused = true;
                        pausedTime = startTime;

                        // Set up MediaRecorder
                        const stream = canvas.captureStream(fps);
                        const recorder = new MediaRecorder(stream, {
                            mimeType: "video/webm",
                            videoBitsPerSecond: bitrate * 1000000,
                        });

                        // Collect video chunks
                        const chunks = [];
                        recorder.ondataavailable = (e) => chunks.push(e.data);
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, {
                                type: "video/webm",
                            });
                            const url = URL.createObjectURL(blob);

                            // Create download link
                            const link = document.createElement("a");
                            link.href = url;
                            link.download = "shader_animation.webm";
                            link.click();

                            log("Animation exported as WebM");
                            log(`Download links: [WebM](${url})`);

                            // Resume normal operation
                            timePaused = false;
                            startTime = Date.now();
                            log("Export complete!");
                        };

                        recorder.start();

                        // Render frames for animation
                        let currentTime = startTime;
                        const endTime = startTime + duration;
                        const frameInterval = 1000 / fps;

                        function renderFrame() {
                            if (currentTime >= endTime) {
                                recorder.stop();
                                return;
                            }

                            pausedTime = currentTime;
                            render();
                            currentTime += frameInterval / 1000;
                            setTimeout(renderFrame, frameInterval);
                        }

                        renderFrame();
                    } catch (error) {
                        log(`Error exporting animation: ${error}`, "error");
                        timePaused = false;
                    }
                }
            }

            // ==================== FULLSCREEN PREVIEW ====================

            /**
             * Opens the fullscreen preview
             */
            function openFullscreenPreview() {
                if (!image) return;

                fsContainer.style.display = "flex";
                fsTimePaused = false;
                $("fullscreenPauseTime").textContent = "Pause Animation";

                fsCanvas.width = canvas.width;
                fsCanvas.height = canvas.height;

                // Initialize WebGL context if not already done
                if (!fsGl) {
                    fsGl = fsCanvas.getContext("webgl");
                    if (!fsGl) {
                        log(
                            "Failed to initialize WebGL for fullscreen preview",
                            "error",
                        );
                        return;
                    }
                }

                setupFullscreenCanvas();
                animateFullscreen();
            }

            /**
             * Renders the fullscreen preview animation
             */
            function animateFullscreen() {
                if (fsTimePaused) return;
                renderFullscreen();
                fsAnimFrame = requestAnimationFrame(animateFullscreen);
            }

            /**
             * Sets up the fullscreen canvas with shaders
             */
            function setupFullscreenCanvas() {
                // Ensure fsGl context exists
                if (!fsGl) {
                    log("Fullscreen WebGL context not available.", "error");
                    closeFullscreenPreview(); // Exit if no context
                    return;
                }

                const vertexSource = $("vertexShader").textContent;
                const customFragmentSource = codeTextarea.value.trim();
                const defaultFragmentSource = $(
                    "defaultFragmentShader",
                ).textContent;

                let fragmentSourceToUse;

                // Determine which fragment shader source to use
                if (shaderActive && customFragmentSource) {
                    // Use custom shader if it's active and the editor isn't empty
                    fragmentSourceToUse = customFragmentSource;
                    log("Fullscreen: Using custom shader from editor.");
                } else {
                    // Otherwise, use the default pass-through shader
                    fragmentSourceToUse = defaultFragmentSource;
                    if (!shaderActive) {
                        log(
                            "Fullscreen: Shader inactive, using default pass-through.",
                        );
                    } else {
                        log(
                            "Fullscreen: Editor empty, using default pass-through.",
                        );
                    }
                }

                // Create shaders
                const vertexShader = createShader(
                    fsGl,
                    fsGl.VERTEX_SHADER,
                    vertexSource,
                );
                const fragmentShader = createShader(
                    fsGl,
                    fsGl.FRAGMENT_SHADER,
                    fragmentSourceToUse, // Use the correctly chosen source
                );

                // Check for shader creation errors
                if (!vertexShader || !fragmentShader) {
                    log(
                        "Fullscreen: Failed to create shaders. Cannot display preview.",
                        "error",
                    );
                    closeFullscreenPreview(); // Exit if shaders fail
                    return;
                }

                // Create program
                const fsProgram = createProgram(
                    fsGl,
                    vertexShader,
                    fragmentShader,
                );

                // Check for program linking errors
                if (!fsProgram) {
                    log(
                        "Fullscreen: Failed to link program. Cannot display preview.",
                        "error",
                    );
                    // Clean up shaders if program linking failed
                    fsGl.deleteShader(vertexShader);
                    fsGl.deleteShader(fragmentShader);
                    closeFullscreenPreview(); // Exit if program fails
                    return;
                }

                // --- Program linked successfully, continue setup ---
                fsGl.useProgram(fsProgram);

                // Set up position buffer
                const posBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.bufferData(
                    fsGl.ARRAY_BUFFER,
                    new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                    fsGl.STATIC_DRAW,
                );

                // Set up texture coordinates (using the same logic as the main canvas)
                const texCoords = getTransformedTexCoords();
                const texBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.bufferData(
                    fsGl.ARRAY_BUFFER,
                    new Float32Array(texCoords),
                    fsGl.STATIC_DRAW,
                );

                // Set up attributes
                const posLoc = fsGl.getAttribLocation(fsProgram, "a_position");
                const texLoc = fsGl.getAttribLocation(fsProgram, "a_texcoord");

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.enableVertexAttribArray(posLoc);
                fsGl.vertexAttribPointer(posLoc, 2, fsGl.FLOAT, false, 0, 0);

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.enableVertexAttribArray(texLoc);
                fsGl.vertexAttribPointer(texLoc, 2, fsGl.FLOAT, false, 0, 0);

                // Set up texture
                // Important: Need to create a *new* texture for the fsGl context
                const fsTexture = fsGl.createTexture();
                fsGl.bindTexture(fsGl.TEXTURE_2D, fsTexture);

                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_WRAP_S,
                    fsGl.CLAMP_TO_EDGE,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_WRAP_T,
                    fsGl.CLAMP_TO_EDGE,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_MIN_FILTER,
                    fsGl.LINEAR,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_MAG_FILTER,
                    fsGl.LINEAR,
                );

                // Upload the *same image data* to the new texture
                if (image) {
                    fsGl.texImage2D(
                        fsGl.TEXTURE_2D,
                        0,
                        fsGl.RGBA,
                        fsGl.RGBA,
                        fsGl.UNSIGNED_BYTE,
                        image,
                    );
                } else {
                    // Handle case where there's no image? Maybe show black or checkerboard?
                    // For now, just log it. The preview won't work without an image anyway.
                    log(
                        "Fullscreen: No image loaded, texture will be empty.",
                        "warning",
                    );
                }

                // Set texture uniform
                const texUnitLoc = fsGl.getUniformLocation(fsProgram, "tex");
                fsGl.uniform1i(texUnitLoc, 0); // Use texture unit 0

                // Set time uniform (initial value)
                const timeLoc = fsGl.getUniformLocation(fsProgram, "time");
                if (timeLoc) {
                    let initialTime = 0;
                    if (timePaused && pausedTime !== null) {
                        initialTime = pausedTime;
                    } else {
                        // Use the same basis as the main animation loop
                        initialTime = (Date.now() - startTime) / 1000.0;
                    }
                    fsGl.uniform1f(timeLoc, initialTime);
                    log(`Fullscreen: Initial time set to ${initialTime}`);
                } else {
                    log("Fullscreen: Shader does not use 'time' uniform.");
                }

                // No need to delete shaders immediately if linking was successful,
                // they are attached to the program. They can be deleted after linking.
                fsGl.deleteShader(vertexShader);
                fsGl.deleteShader(fragmentShader);

                log("Fullscreen canvas setup complete.");
            }

            /**
             * Renders a single frame in fullscreen mode
             */
            function renderFullscreen() {
                if (!fsGl) return;

                fsGl.viewport(0, 0, fsCanvas.width, fsCanvas.height);

                // Set clear color
                let r = 0,
                    g = 0,
                    b = 0,
                    a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }

                fsGl.clearColor(r, g, b, a);
                fsGl.clear(fsGl.COLOR_BUFFER_BIT);

                // Update time uniform if needed
                const program = fsGl.getParameter(fsGl.CURRENT_PROGRAM);
                const timeLoc = fsGl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (fsTimePaused) {
                        const currentTime = fsGl.getUniform(program, timeLoc);
                        fsGl.uniform1f(timeLoc, currentTime);
                    } else if (timePaused && pausedTime !== null) {
                        fsGl.uniform1f(timeLoc, pausedTime);
                    } else {
                        fsGl.uniform1f(
                            timeLoc,
                            (Date.now() - startTime) / 1000.0,
                        );
                    }
                }

                // Draw the quad
                fsGl.drawArrays(fsGl.TRIANGLE_STRIP, 0, 4);
            }

            /**
             * Closes the fullscreen preview
             */
            function closeFullscreenPreview() {
                fsContainer.style.display = "none";
                if (fsAnimFrame) {
                    cancelAnimationFrame(fsAnimFrame);
                    fsAnimFrame = null;
                }
            }

            // ==================== HISTORY MANAGEMENT ====================

            /**
             * Saves current state to history
             */
            function saveToHistory() {
                const newState = {
                    shaderCode: codeTextarea.value,
                    rotation,
                    mirrorX,
                    mirrorY,
                    canvas: { ...canvasState },
                    bgColor,
                    useTransparent,
                };

                // Truncate history if we've undone some actions
                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }

                history.push(newState);
                historyIndex = history.length - 1;

                // Limit history size
                if (history.length > maxHistory) {
                    history.shift();
                    historyIndex--;
                }

                updateHistoryBtns();
            }

            /**
             * Updates undo/redo button states
             */
            function updateHistoryBtns() {
                $("undoButton").disabled = historyIndex <= 0;
                $("redoButton").disabled = historyIndex >= history.length - 1;
            }

            /**
             * Applies a state from history
             * @param {Object} state - The state to apply
             */
            function applyHistoryState(state) {
                codeTextarea.value = state.shaderCode;
                rotation = state.rotation;
                mirrorX = state.mirrorX;
                mirrorY = state.mirrorY;
                canvasState = { ...state.canvas };
                bgColor = state.bgColor;
                useTransparent = state.useTransparent;

                // Update UI to match state
                transCanvas.checked = useTransparent;
                bgColorInput.value = bgColor;
                bgColorPreview.style.backgroundColor = bgColor;

                updateRotationUI();
                updateCanvasUI();
                compileShader();
                updateTransform();
                updateCanvasDisplay();
            }

            // ==================== SAVE SLOTS ====================

            /**
             * Initializes save slot functionality
             */
            function initSaveSlots() {
                const saveSlots = document.querySelectorAll(".save-slot");
                const unloadSlotBtn = $("unloadSlot");
                let activeSlot = null; // Stores the number (string) of the active slot

                function updateUnloadButtonVisibility() {
                    if (activeSlot) {
                        unloadSlotBtn.style.display = "inline-block";
                    } else {
                        unloadSlotBtn.style.display = "none";
                    }
                }

                saveSlots.forEach((slot) => {
                    const slotNum = slot.dataset.slot;

                    if (localStorage.getItem(`glsl-shader-slot-${slotNum}`)) {
                        // Optional indicator
                    }

                    slot.textContent = `Slot ${slotNum}`;
                    slot.dataset.state = "default";
                    let timer = null;

                    function resetSlot() {
                        slot.textContent = `Slot ${slotNum}`;
                        if (activeSlot === slotNum) {
                            slot.classList.add("active");
                        } else {
                            slot.classList.remove("active");
                        }
                        slot.dataset.state = "default";
                        timer = null;
                        updateUnloadButtonVisibility();
                    }

                    // Left-click handler
                    slot.addEventListener("click", (e) => {
                        e.preventDefault();

                        // Handle clear confirmation abort
                        if (slot.dataset.state === "confirm_clear") {
                            if (timer) clearTimeout(timer);
                            slot.textContent = "aborted";
                            slot.dataset.state = "finish";
                            timer = setTimeout(resetSlot, 1000);
                            return;
                        }

                        // Default state behavior
                        if (slot.dataset.state === "default") {
                            if (
                                localStorage.getItem(
                                    `glsl-shader-slot-${slotNum}`,
                                )
                            ) {
                                slot.textContent = "load?";
                                slot.dataset.state = "confirm_load";
                            } else {
                                slot.textContent = "save?";
                                slot.dataset.state = "confirm_save";
                            }
                            timer = setTimeout(resetSlot, 3000);
                            return;
                        }

                        // Confirm save
                        if (slot.dataset.state === "confirm_save") {
                            if (timer) clearTimeout(timer);
                            const shaderCodeToSave = codeTextarea.value;
                            localStorage.setItem(
                                `glsl-shader-slot-${slotNum}`,
                                shaderCodeToSave,
                            );

                            saveSlots.forEach((s) =>
                                s.classList.remove("active"),
                            );
                            slot.classList.add("active");
                            activeSlot = slotNum;
                            updateUnloadButtonVisibility();

                            compileShader();
                            render();

                            slot.textContent = "saved!";
                            slot.dataset.state = "finish";
                            timer = setTimeout(resetSlot, 1000);

                            log(
                                `Shader saved to and loaded from Slot ${slotNum}`,
                            );
                            return;
                        }

                        // Confirm load
                        if (slot.dataset.state === "confirm_load") {
                            if (timer) clearTimeout(timer);
                            const savedContent = localStorage.getItem(
                                `glsl-shader-slot-${slotNum}`,
                            );
                            if (savedContent) {
                                codeTextarea.value = savedContent;

                                compileShader();
                                render();

                                saveSlots.forEach((s) =>
                                    s.classList.remove("active"),
                                );
                                slot.classList.add("active");
                                activeSlot = slotNum;
                                updateUnloadButtonVisibility();

                                slot.textContent = "loaded!";
                                slot.dataset.state = "finish";
                                timer = setTimeout(resetSlot, 1000);

                                log(`Shader loaded from Slot ${slotNum}`);

                                updateLoadShaderBorder(); // Editor is no longer empty
                            } else {
                                slot.textContent = "load failed";
                                slot.dataset.state = "finish";
                                timer = setTimeout(resetSlot, 1000);
                                log(
                                    `Failed to load Slot ${slotNum} - not found`,
                                    "error",
                                );
                            }
                            return;
                        }
                    }); // End left-click handler

                    // Right-click handler
                    slot.addEventListener("contextmenu", (e) => {
                        e.preventDefault();

                        if (
                            slot.dataset.state === "confirm_save" ||
                            slot.dataset.state === "confirm_load"
                        ) {
                            if (timer) clearTimeout(timer);
                            slot.textContent = "aborted";
                            slot.dataset.state = "finish";
                            timer = setTimeout(resetSlot, 1000);
                            return;
                        }

                        if (slot.dataset.state === "default") {
                            if (
                                localStorage.getItem(
                                    `glsl-shader-slot-${slotNum}`,
                                )
                            ) {
                                slot.textContent = "clear?";
                                slot.dataset.state = "confirm_clear";
                                timer = setTimeout(resetSlot, 3000);
                            } else {
                                slot.textContent = "empty";
                                slot.dataset.state = "finish";
                                timer = setTimeout(resetSlot, 1000);
                            }
                            return;
                        }

                        // Confirm clear
                        if (slot.dataset.state === "confirm_clear") {
                            if (timer) clearTimeout(timer);
                            const wasActive = activeSlot === slotNum; // Check if it was active *before* clearing
                            localStorage.removeItem(
                                `glsl-shader-slot-${slotNum}`,
                            );
                            slot.textContent = "cleared!";
                            slot.dataset.state = "finish";

                            if (wasActive) {
                                // Use the stored boolean
                                slot.classList.remove("active");
                                const previouslyActiveSlot = activeSlot; // Store for logging
                                activeSlot = null;
                                updateUnloadButtonVisibility();
                                log(
                                    `Cleared active Slot ${previouslyActiveSlot}`,
                                );
                                // Optionally load default shader when clearing the active slot?
                                // compileDefaultShader();
                                // render();
                            } else {
                                log(`Cleared Slot ${slotNum}`);
                            }

                            timer = setTimeout(resetSlot, 1000);
                            return;
                        }
                    }); // End right-click handler
                }); // End forEach slot

                // Add event listener for the unload button
                unloadSlotBtn.addEventListener("click", () => {
                    if (activeSlot) {
                        const previouslyActiveSlot = activeSlot; // Store for logging
                        const activeSlotElement = document.querySelector(
                            `.save-slot[data-slot="${activeSlot}"]`,
                        );

                        // Check if editor content matches unloaded slot
                        const currentEditorCode = codeTextarea.value; // Get current code before unload
                        const savedSlotCode = localStorage.getItem(
                            `glsl-shader-slot-${previouslyActiveSlot}`,
                        );
                        // Check if saved code exists and matches the editor
                        const shouldWipeEditor =
                            savedSlotCode !== null &&
                            currentEditorCode === savedSlotCode;
                        // Deactivate the visual slot
                        if (activeSlotElement) {
                            activeSlotElement.classList.remove("active");
                        }
                        activeSlot = null; // Clear the active slot tracker
                        updateUnloadButtonVisibility(); // Hide the unload button

                        // Load the default shader (this will update apply border via its own logic)
                        compileDefaultShader();
                        render();

                        // Wipe editor if content matched
                        if (shouldWipeEditor) {
                            codeTextarea.value = ""; // Clear the editor
                            log(
                                `Unloaded active Slot ${previouslyActiveSlot}, editor cleared. Default shader active.`,
                            );
                            // Trigger border updates since editor changed
                            updateLoadShaderBorder(); // Editor is now empty
                        } else {
                            log(
                                `Unloaded active Slot ${previouslyActiveSlot}. Editor content preserved. Default shader active.`,
                            );
                        }
                    } else {
                        // Should not happen if button visibility is correct, but good practice
                        log("No slot is currently active to unload.", "info");
                        updateUnloadButtonVisibility(); // Ensure it's hidden
                    }
                });
                // Ensure initial visibility check is present
                updateUnloadButtonVisibility(); // Check visibility on load
            } // End initSaveSlots

            // ==================== UI UPDATERS ====================

            /**
             * Updates rotation UI to reflect current state
             */
            function updateRotationUI() {
                document
                    .querySelectorAll(".rotation-preset")
                    .forEach((preset) => {
                        if (parseInt(preset.dataset.rotation) === rotation) {
                            preset.classList.add("active");
                        } else {
                            preset.classList.remove("active");
                        }
                    });
            }

            /**
             * Updates canvas UI inputs to reflect current state
             */
            function updateCanvasUI() {
                $("canvasX").value = canvasState.x;
                $("canvasY").value = canvasState.y;
                $("canvasWidth").value = canvasState.width;
                $("canvasHeight").value = canvasState.height;
            }

            // Middle-click/Touch drag for number inputs

            // Configuration
            const dragSensitivity = 0.1; // Adjusts how much the value changes per pixel dragged. Lower = faster change.
            const dragPixelsPerStep = 10; // How many pixels to drag for one 'step' increment/decrement.

            let isDraggingInput = false;
            let dragTargetInput = null;
            let dragStartX = 0;
            let dragStartValue = 0;
            let dragStep = 1; // Default step

            /**
             * Finds the number input associated with a drag event target.
             * Searches within the parent '.var-row'.
             * @param {EventTarget} target - The element where the event originated.
             * @returns {HTMLInputElement|null} The associated number input or null.
             */
            function findNumberInputForDrag(target) {
                const varRow = target.closest(".var-row");
                if (varRow) {
                    // Prioritize number input directly, then search within row
                    if (
                        target.matches('input[type="number"]') &&
                        !target.disabled &&
                        !target.readOnly
                    ) {
                        return target;
                    }
                    const input = varRow.querySelector(
                        'input[type="number"]:not(:disabled):not([readonly])',
                    );
                    return input;
                }
                return null;
            }

            /**
             * Calculates the number of decimal places based on the step attribute.
             * @param {string|number} stepAttr - The step attribute value.
             * @returns {number} The number of decimal places.
             */
            function getDecimalPlaces(stepAttr) {
                if (
                    !stepAttr ||
                    stepAttr === "any" ||
                    isNaN(parseFloat(stepAttr))
                ) {
                    return 2; // Default decimal places if step is invalid or 'any'
                }
                const stepStr = String(stepAttr);
                const decimalPointIndex = stepStr.indexOf(".");
                if (decimalPointIndex === -1) {
                    return 0; // Integer step
                }
                return stepStr.length - decimalPointIndex - 1;
            }

            function handleDragStart(event) {
                const targetInput = findNumberInputForDrag(event.target);
                if (!targetInput) return; // Not a valid target

                let isMiddleClick =
                    event.type === "mousedown" && event.button === 1;
                let isTouch = event.type === "touchstart";

                if (!isMiddleClick && !isTouch) return; // Only middle mouse or touch

                isDraggingInput = true;
                dragTargetInput = targetInput;
                dragStartValue = parseFloat(targetInput.value) || 0;

                // Determine step value
                const stepAttr = targetInput.step;
                if (stepAttr && stepAttr !== "any") {
                    dragStep = parseFloat(stepAttr);
                } else {
                    // Basic heuristic for default step if not specified
                    const minVal = parseFloat(targetInput.min);
                    if (!isNaN(minVal) && minVal % 1 !== 0) {
                        dragStep = 0.1; // Assume decimal if min is decimal
                    } else {
                        dragStep = 1; // Default to integer step
                    }
                }
                // Ensure dragStep is valid
                if (isNaN(dragStep) || dragStep <= 0) dragStep = 1;

                if (isTouch) {
                    dragStartX = event.touches[0].clientX;
                    // Add touch move/end listeners to the document
                    document.addEventListener("touchmove", handleDragMove, {
                        passive: false,
                    }); // Need passive:false to preventDefault scroll
                    document.addEventListener("touchend", handleDragEnd);
                    document.addEventListener("touchcancel", handleDragEnd);
                } else {
                    dragStartX = event.clientX;
                    // Add mouse move/up listeners to the document
                    document.addEventListener("mousemove", handleDragMove);
                    document.addEventListener("mouseup", handleDragEnd);
                    document.addEventListener("mouseleave", handleDragEnd); // Stop if mouse leaves window
                    event.preventDefault(); // Prevent default middle-click actions (scroll/paste)
                }

                // Optional: Add visual feedback
                document.body.style.cursor = "ew-resize"; // Change cursor
                dragTargetInput.closest(".var-row")?.classList.add("dragging");
            }

            function handleDragMove(event) {
                if (!isDraggingInput || !dragTargetInput) return;

                let currentX = 0;
                if (event.type === "touchmove") {
                    if (event.touches.length === 0) return; // Should not happen, but safety check
                    currentX = event.touches[0].clientX;
                    event.preventDefault(); // Prevent scrolling during swipe
                } else {
                    currentX = event.clientX;
                }

                const deltaX = currentX - dragStartX;

                // Calculate change based on pixels dragged and step
                const stepsMoved = Math.round(deltaX / dragPixelsPerStep);
                let newValue = dragStartValue + stepsMoved * dragStep;

                // Clamp value within min/max bounds
                const minVal = parseFloat(dragTargetInput.min);
                const maxVal = parseFloat(dragTargetInput.max);
                if (!isNaN(minVal)) {
                    newValue = Math.max(minVal, newValue);
                }
                if (!isNaN(maxVal)) {
                    newValue = Math.min(maxVal, newValue);
                }

                // Round to appropriate decimal places based on step
                const decimalPlaces = getDecimalPlaces(dragTargetInput.step);
                newValue = parseFloat(newValue.toFixed(decimalPlaces));

                // Update the input value only if it changed
                if (dragTargetInput.value !== String(newValue)) {
                    dragTargetInput.value = newValue;
                    // Dispatch change event so other listeners react
                    dragTargetInput.dispatchEvent(new Event("change"));
                    // Dispatch input event for live updates if needed by other parts
                    dragTargetInput.dispatchEvent(new Event("input"));
                }
            }

            function handleDragEnd(event) {
                if (!isDraggingInput) return;

                // Remove document-level listeners
                if (event.type.startsWith("touch")) {
                    document.removeEventListener("touchmove", handleDragMove);
                    document.removeEventListener("touchend", handleDragEnd);
                    document.removeEventListener("touchcancel", handleDragEnd);
                } else {
                    document.removeEventListener("mousemove", handleDragMove);
                    document.removeEventListener("mouseup", handleDragEnd);
                    document.removeEventListener("mouseleave", handleDragEnd);
                }

                // Reset state
                isDraggingInput = false;

                // Optional: Remove visual feedback
                document.body.style.cursor = ""; // Reset cursor
                dragTargetInput
                    ?.closest(".var-row")
                    ?.classList.remove("dragging");

                dragTargetInput = null; // Clear reference
            }

            // Attach listeners to a suitable container (e.g., document body or specific sections)
            // Using document.body allows this to work even if inputs are added dynamically.
            document.body.addEventListener("mousedown", handleDragStart);
            document.body.addEventListener("touchstart", handleDragStart, {
                passive: true,
            }); // Use passive:true for touchstart if not preventing default scroll initially

            // Prevent the default context menu on middle-click for the specific rows
            // to avoid conflicts if the drag doesn't start immediately.
            document.querySelectorAll(".var-row").forEach((row) => {
                row.addEventListener("contextmenu", (event) => {
                    if (event.button === 1) {
                        // If middle mouse button caused the contextmenu event
                        const input = findNumberInputForDrag(event.target);
                        if (input) {
                            event.preventDefault(); // Prevent context menu only if related to a number input row
                        }
                    }
                });
            });

            // Optional: Add a CSS class for visual feedback during drag
            /*
            .var-row.dragging {
                cursor: ew-resize;
                background-color: rgba(255, 255, 255, 0.1); // Example highlight
            }
            */

            // Add Shift + Arrow Key modifier for number inputs

            /**
             * Handles keydown events on number inputs for step modification.
             * @param {KeyboardEvent} event
             */
            function handleNumberInputKeyDown(event) {
                const targetInput = event.target;

                // Check if it's a number input and ArrowUp or ArrowDown
                if (
                    targetInput.type !== "number" ||
                    (event.key !== "ArrowUp" && event.key !== "ArrowDown") ||
                    targetInput.disabled ||
                    targetInput.readOnly
                ) {
                    return; // Ignore if not relevant
                }

                // Determine the step value
                let step = 1; // Default step
                const stepAttr = targetInput.step;
                if (
                    stepAttr &&
                    stepAttr !== "any" &&
                    !isNaN(parseFloat(stepAttr))
                ) {
                    step = parseFloat(stepAttr);
                } else {
                    // Basic heuristic for default step if not specified
                    const minVal = parseFloat(targetInput.min);
                    if (!isNaN(minVal) && minVal % 1 !== 0) {
                        step = 0.1; // Assume decimal if min is decimal
                    }
                }
                if (isNaN(step) || step <= 0) step = 1; // Ensure valid step

                // Apply modifier if Shift key is pressed
                const multiplier = event.shiftKey ? 2 : 1;
                const effectiveStep = step * multiplier;

                // Get current value
                let currentValue = parseFloat(targetInput.value);
                if (isNaN(currentValue)) {
                    // Try to use min, max, or default value if current is invalid
                    currentValue =
                        parseFloat(targetInput.defaultValue) ||
                        parseFloat(targetInput.min) ||
                        0;
                    if (isNaN(currentValue)) currentValue = 0; // Absolute fallback
                }

                // Calculate new value
                let newValue =
                    currentValue +
                    (event.key === "ArrowUp" ? effectiveStep : -effectiveStep);

                // Clamp value within min/max bounds
                const minVal = parseFloat(targetInput.min);
                const maxVal = parseFloat(targetInput.max);
                if (!isNaN(minVal)) {
                    newValue = Math.max(minVal, newValue);
                }
                if (!isNaN(maxVal)) {
                    newValue = Math.min(maxVal, newValue);
                }

                // Round to appropriate decimal places based on original step
                const decimalPlaces = getDecimalPlaces(stepAttr); // Use original step for rounding precision
                newValue = parseFloat(newValue.toFixed(decimalPlaces));

                // Prevent default arrow key behavior
                event.preventDefault();

                // Update the input value only if it changed
                if (targetInput.value !== String(newValue)) {
                    targetInput.value = newValue;
                    // Dispatch change event so other listeners react
                    targetInput.dispatchEvent(new Event("change"));
                    // Dispatch input event for live updates if needed
                    targetInput.dispatchEvent(new Event("input"));
                }
            }

            // Replace handleDragMove with version including Shift key logic
            function handleDragMove(event) {
                if (!isDraggingInput || !dragTargetInput) return;

                let currentX = 0;
                // Check shiftKey state within the move handler
                const isShiftPressed = event.shiftKey; // Check if Shift is held *during* move

                if (event.type === "touchmove") {
                    if (event.touches.length === 0) return;
                    currentX = event.touches[0].clientX;
                    event.preventDefault(); // Prevent scrolling during swipe
                } else {
                    currentX = event.clientX;
                }

                const deltaX = currentX - dragStartX;
                const stepsMoved = Math.round(deltaX / dragPixelsPerStep);

                // Apply precision modifier if Shift is pressed
                const precisionMultiplier = isShiftPressed ? 0.5 : 1;
                const valueChange = stepsMoved * dragStep * precisionMultiplier;
                let newValue = dragStartValue + valueChange;

                // Clamp value within min/max bounds (remains the same)
                const minVal = parseFloat(dragTargetInput.min);
                const maxVal = parseFloat(dragTargetInput.max);
                if (!isNaN(minVal)) {
                    newValue = Math.max(minVal, newValue);
                }
                if (!isNaN(maxVal)) {
                    newValue = Math.min(maxVal, newValue);
                }

                // Round to appropriate decimal places based on step (remains the same)
                // Use original dragStep for rounding precision, not the modified one
                const decimalPlaces = getDecimalPlaces(dragTargetInput.step);
                newValue = parseFloat(newValue.toFixed(decimalPlaces));

                // Update the input value only if it changed (remains the same)
                if (dragTargetInput.value !== String(newValue)) {
                    dragTargetInput.value = newValue;
                    dragTargetInput.dispatchEvent(new Event("change"));
                    dragTargetInput.dispatchEvent(new Event("input"));
                }
            }

            // Attach listener using event delegation on the body
            document.body.addEventListener("keydown", handleNumberInputKeyDown);

            // ==================== EVENT LISTENERS ====================

            // Initialize WebGL
            if (!gl) {
                log("WebGL not supported!", "error");
            } else {
                log("WebGL initialized successfully");
                initWebGL();
            }

            // Initialize save slots
            initSaveSlots();

            // External image URL handling
            externalImageUrl.addEventListener("input", () => {
                const url = externalImageUrl.value.trim();
                const isValid = url.match(/\.(jpeg|jpg|gif|png|webp)$/) != null;

                if (isValid) {
                    loadImageByUrl.style.display = "inline-block";
                    clearExternalUrl.style.display = "none";
                } else {
                    loadImageByUrl.style.display = "none";
                    clearExternalUrl.style.display = "none";
                }
            });

            externalImageUrl.addEventListener("keydown", (e) => {
                if (e.key === "Enter" || e.keyCode === 13) {
                    e.preventDefault();
                    if (loadImageByUrl.style.display === "inline-block") {
                        loadImageByUrl.click();
                    }
                }
            });

            // Load external image
            loadImageByUrl.addEventListener("click", async () => {
                const url = externalImageUrl.value.trim();
                try {
                    // Test load first
                    const testImg = new Image();
                    testImg.onerror = () => {
                        throw new Error("Failed to load image");
                    };

                    await new Promise((resolve, reject) => {
                        testImg.onload = resolve;
                        testImg.onerror = reject;
                        testImg.src = url;
                    });

                    // If test succeeds, load actual image
                    const img = new Image();
                    img.crossOrigin = "Anonymous";
                    img.onload = () => {
                        image = img;
                        canvas.width = img.width;
                        canvas.height = img.height;

                        canvasState = {
                            x: 0,
                            y: 0,
                            width: img.width,
                            height: img.height,
                        };

                        updateCanvasUI();
                        createImageTexture();
                        initBuffers();
                        updateCanvasDisplay();
                        startRendering();
                        saveToHistory();

                        // Update UI
                        loadImageByUrl.style.display = "none";
                        clearExternalUrl.style.display = "inline-block";
                        updateImageButtons();
                        log(`External image loaded from URL: ${url}`);
                    };
                    img.onerror = () => {
                        log(`Error loading image from URL: ${url}`, "error");
                    };
                    img.src = url;
                } catch (err) {
                    log(`Error loading image: ${err.message}`, "error");
                }
            });

            // Clear external URL
            clearExternalUrl.addEventListener("click", () => {
                externalImageUrl.value = "";
                loadImageByUrl.style.display = "none";
                clearExternalUrl.style.display = "none";

                // Unload current external image if needed
                if (image && image.src === externalImageUrl.value.trim()) {
                    image = null;
                    updateImageButtons();
                    log("External image unloaded");
                }
            });

            // Drag and drop support
            document.addEventListener("dragover", (e) => {
                e.preventDefault();
                canvasContainer.classList.add("drag-over");
            });

            document.addEventListener("dragleave", () => {
                canvasContainer.classList.remove("drag-over");
            });

            document.addEventListener("drop", (e) => {
                e.preventDefault();
                canvasContainer.classList.remove("drag-over");

                const dt = e.dataTransfer;
                if (dt.files.length > 0) {
                    handleImageFile(dt.files[0]);
                } else if (dt.items) {
                    // Handle pasted images from clipboard
                    for (let i = 0; i < dt.items.length; i++) {
                        if (
                            dt.items[i].kind === "file" &&
                            dt.items[i].type.match("^image/")
                        ) {
                            handleImageFile(dt.items[i].getAsFile());
                            break;
                        }
                    }
                }
            });

            // Paste support
            document.addEventListener("paste", (e) => {
                const items = e.clipboardData.items;
                for (let i = 0; i < items.length; i++) {
                    if (items[i].type.indexOf("image") !== -1) {
                        const blob = items[i].getAsFile();
                        handleImageFile(blob);
                        break;
                    }
                }
            });

            // File input handling
            $("loadImage").addEventListener("click", () =>
                $("imageInput").click(),
            );
            $("imageInput").addEventListener("change", (e) => {
                if (e.target.files.length > 0) {
                    handleImageFile(e.target.files[0]);
                }
            });

            // Shader file loading
            $("loadShader").addEventListener("click", () =>
                $("shaderInput").click(),
            );
            $("shaderInput").addEventListener("change", (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        codeTextarea.value = evt.target.result;
                        log(`Shader loaded: ${file.name}`);
                        saveToHistory();
                        updateLoadShaderBorder(); // Editor is no longer empty
                    };
                    reader.readAsText(file);
                }
            });

            // Save current slot
            $("saveCurrentSlot").addEventListener("click", () => {
                const activeSlot = document.querySelector(".save-slot.active");
                if (activeSlot) {
                    const slotNum = activeSlot.dataset.slot;
                    localStorage.setItem(
                        `glsl-shader-slot-${slotNum}`,
                        codeTextarea.value,
                    );
                    log(`Saved shader to slot ${slotNum}`);
                } else {
                    localStorage.setItem("glsl-shader", codeTextarea.value);
                    log("No slot selected. Shader saved to general storage.");
                }
            });

            // Time control
            $("pauseTime").addEventListener("click", () => {
                timePaused = !timePaused;

                if (timePaused) {
                    pausedTime = (Date.now() - startTime) / 1000.0;
                    $("pauseTime").classList.add("active");
                    $("pauseTime").textContent = "Resume Time";
                } else {
                    pausedTime = null;
                    startTime = Date.now();
                    $("pauseTime").classList.remove("active");
                    $("pauseTime").textContent = "Pause Time";
                }

                log(`Time ${timePaused ? "paused" : "resumed"}`);
            });

            // Fullscreen controls
            $("fullscreenPreview").addEventListener(
                "click",
                openFullscreenPreview,
            );
            $("fullscreenPauseTime").addEventListener("click", () => {
                fsTimePaused = !fsTimePaused;
                $("fullscreenPauseTime").textContent = fsTimePaused
                    ? "Resume Animation"
                    : "Pause Animation";

                if (fsGl) {
                    if (fsAnimFrame) cancelAnimationFrame(fsAnimFrame);
                    if (!fsTimePaused) {
                        animateFullscreen();
                    } else {
                        renderFullscreen();
                    }
                }
            });

            // Exit fullscreen
            document
                .querySelector(".exit-fullscreen")
                .addEventListener("click", closeFullscreenPreview);
            fsContainer.addEventListener("click", (e) => {
                if (e.target === fsContainer) closeFullscreenPreview();
            });

            // Escape key to exit fullscreen
            document.addEventListener("keydown", (e) => {
                if (
                    e.key === "Escape" &&
                    fsContainer.style.display !== "none"
                ) {
                    closeFullscreenPreview();
                }
            });

            // Shader controls
            $("updateShader").addEventListener("click", () => {
                const codeToCompile = codeTextarea.value.trim();
                compileShader();
                // Check if the program exists (compileShader didn't return early on error)
                // and if the source matches what we intended to compile
                if (program && codeToCompile.length > 0) {
                    // A crude check: does the current program's source match?
                    // This is imperfect but better than nothing. A more robust check
                    // would involve getting shader source from WebGL, which is complex.
                    // For now, assume success if compileShader didn't error out.
                    lastCompiledCode = codeToCompile;
                }
                render();
                saveToHistory();
                log("Shader updated!");
            });

            $("toggleShader").addEventListener("click", () => {
                shaderActive = !shaderActive;
                if (shaderActive) {
                    log("Shader toggled on.");
                    compileShader();
                } else {
                    log("Shader toggled off.");
                    compileDefaultShader();
                }
                render();
            });

            // Image export
            $("savePNG").addEventListener("click", () => saveImage("png"));
            $("saveJPG").addEventListener("click", () => saveImage("jpeg"));
            $("exportMp4").addEventListener("click", () =>
                exportAnimation("webm"),
            );

            // Transform controls
            document.querySelectorAll(".rotation-preset").forEach((preset) => {
                preset.addEventListener("click", () => {
                    rotation = parseInt(preset.dataset.rotation);
                    updateRotationUI();
                    updateTransform();
                    saveToHistory();
                });
            });

            $("resetRotation").addEventListener("click", () => {
                rotation = 0;
                updateRotationUI();
                updateTransform();
                saveToHistory();
            });

            $("resetMirror").addEventListener("click", () => {
                mirrorX = mirrorY = false;
                updateTransform();
                saveToHistory();
            });

            $("resetCanvas").addEventListener("click", () => {
                if (image) {
                    canvasState = {
                        x: 0,
                        y: 0,
                        width: image.width,
                        height: image.height,
                    };
                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            $("resetAspect").addEventListener("click", () => {
                $("aspectW").value = 16;
                $("aspectH").value = 9;
            });

            $("applyAspect").addEventListener("click", () => {
                const aspectW = parseFloat($("aspectW").value) || 16;
                const aspectH = parseFloat($("aspectH").value) || 9;

                if (image) {
                    const targetRatio = aspectW / aspectH;
                    const imgRatio = canvasState.width / canvasState.height;

                    if (imgRatio > targetRatio) {
                        const newWidth = canvasState.height * targetRatio;
                        const deltaX = (canvasState.width - newWidth) / 2;
                        canvasState.x += deltaX;
                        canvasState.width = newWidth;
                    } else {
                        const newHeight = canvasState.width / targetRatio;
                        const deltaY = (canvasState.height - newHeight) / 2;
                        canvasState.y += deltaY;
                        canvasState.height = newHeight;
                    }

                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            $("mirrorX").addEventListener("click", () => {
                mirrorX = !mirrorX;
                $("mirrorX").classList.toggle("active", mirrorX);
                updateTransform();
                saveToHistory();
            });

            $("mirrorY").addEventListener("click", () => {
                mirrorY = !mirrorY;
                $("mirrorY").classList.toggle("active", mirrorY);
                updateTransform();
                saveToHistory();
            });

            // Canvas position controls
            ["canvasX", "canvasY", "canvasWidth", "canvasHeight"].forEach(
                (id) => {
                    $(id).addEventListener("change", () => {
                        canvasState.x = parseFloat($("canvasX").value) || 0;
                        canvasState.y = parseFloat($("canvasY").value) || 0;
                        canvasState.width =
                            parseFloat($("canvasWidth").value) ||
                            image?.width ||
                            0;
                        canvasState.height =
                            parseFloat($("canvasHeight").value) ||
                            image?.height ||
                            0;
                        updateTransform();
                        saveToHistory();
                    });
                },
            );

            // Background controls
            bgColorInput.addEventListener("input", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColorPreview.style.backgroundColor = color;
                }
            });

            $("applyBackground").addEventListener("click", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColor = color;
                    updateCanvasDisplay();
                    log(`Canvas background set to ${color}`);
                    saveToHistory();
                } else {
                    log(
                        "Invalid hex color format. Use #RRGGBB format.",
                        "error",
                    );
                }
            });

            // Transparency controls
            transCanvas.addEventListener("change", () => {
                useTransparent = transCanvas.checked;
                updateCanvasDisplay();
                render();
                saveToHistory();
            });

            exportAlpha.addEventListener("change", () => {
                useExportAlpha = exportAlpha.checked;
            });

            // Zoom controls
            zoomInput.addEventListener("input", () => {
                const newZoom = parseFloat(zoomInput.value);
                // Ensure value is within bounds (browser might handle this, but good practice)
                const minZoom = parseFloat(zoomInput.min) || 0.1;
                const maxZoom = parseFloat(zoomInput.max) || 5;
                if (
                    !isNaN(newZoom) &&
                    newZoom >= minZoom &&
                    newZoom <= maxZoom
                ) {
                    zoomLevel = newZoom;
                    updateCanvasDisplay(); // Keep this to apply zoom
                } else if (isNaN(newZoom)) {
                    // Handle invalid input if necessary, maybe reset or ignore
                } else {
                    // Optionally clamp the value if user types outside bounds
                    zoomLevel = Math.max(minZoom, Math.min(maxZoom, newZoom));
                    zoomInput.value = zoomLevel; // Update input visually
                    updateCanvasDisplay();
                }
            });

            // Reset zoom
            $("resetZoom").addEventListener("click", () => {
                zoomLevel = 1;
                zoomInput.value = 1;
                updateCanvasDisplay(); // Keep this
            });

            // Reset all parameters
            $("resetAllParams").addEventListener("click", () => {
                // ... other resets ...

                // Keep zoom reset part
                zoomLevel = 1;
                zoomInput.value = 1;
                // ... other updates ...
                updateCanvasDisplay(); // Keep this
                saveToHistory();
                log("Most parameters reset to defaults");
            });

            // History controls
            $("undoButton").addEventListener("click", () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            $("redoButton").addEventListener("click", () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            // Unload image
            $("unloadImage").addEventListener("click", () => {
                image = null;
                imageTexture = null;
                gl.clearColor(0, 0, 0, 1);
                gl.clear(gl.COLOR_BUFFER_BIT);
                canvasState = {
                    x: 0,
                    y: 0,
                    width: canvas.width,
                    height: canvas.height,
                };
                log("Image unloaded.");
                updateImageButtons();
            });

            // Initialize WebGL
            function initWebGL() {
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    $("vertexShader").textContent,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    $("defaultFragmentShader").textContent,
                );
                program = createProgram(gl, vertexShader, fragmentShader);
                initBuffers();
                saveToHistory();
            }

            // Start rendering
            startRendering();
            updateRotationUI();
            updateHistoryBtns();
            updateImageButtons();

            // Logic for Load Shader button border

            // Get references to the elements
            const codeTextareaForBorder = $("shaderCode"); // Reusing existing reference is fine
            const loadShaderBtn = $("loadShader");
            const highlightClassName = "highlight-border"; // Define class name

            /**
             * Checks if the shader code textarea is empty and updates the
             * 'Load Shader' button's border class accordingly.
             */
            function updateLoadShaderBorder() {
                if (!codeTextareaForBorder || !loadShaderBtn) return; // Safety check

                const code = codeTextareaForBorder.value.trim(); // Get trimmed content

                if (code.length === 0) {
                    // Textarea is empty, add the border class
                    loadShaderBtn.classList.add(highlightClassName);
                } else {
                    // Textarea has content, remove the border class
                    loadShaderBtn.classList.remove(highlightClassName);
                }
            }

            // Add event listener to the textarea to check on input
            if (codeTextareaForBorder) {
                codeTextareaForBorder.addEventListener("input", () => {
                    // Use arrow function
                    updateLoadShaderBorder();
                });
            }

            // Call the update function once on initial load ---
            // Place this call at the very end of your main script block,
            // after all other initializations and event listeners are set up.
            updateLoadShaderBorder();
        </script>
    </body>
</html>
