<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GLSL Image Shader</title>
        <style>
            :root {
                --bg-dark: #1e0b10;
                --bg-panel: #ff99b21f;
                --bg-console: #000000;
                --border: #ff99b21f;
                --border-input: #ff99b21f;
                --text: #ff99b2;
                --btn-border-active: #ff99b2;
                --btn: #ff99b21f;
                --btn-hover: #ff99b252;
                --btn-active: #ffc2d1;
                --btn-active-text-color: #000000;
                --btn-danger: #ff477552;
                --console-text: #ff99b2;
                --gap: 16px;
                --border-thickness: 2px;
                --border-radius: 8px;
                --margin: 16px;
                --padding: 16px;
                --font-family: sans-serif;
                --button-danger-text-color: #ff99b2;
                --background: var(--bg-dark);
                --h1-color: #ffc2d1;
                --h2-color: #ffc2d1;
                --h3-color: #ffc2d1;
                --slider-color: var(--btn-hover);
                button.border-active {
                    background-color: transparent;
                    border: 2px solid var(--btn-border-active);
                    color: var(--btn-border-active);
                }
            }

            /* Use CSS variables for colors/fonts */
            body {
                background-color: var(--background);
                color: var(--text);
                font-family: var(--font-family);
                margin: var(--padding);
                padding: var(--padding);
            }

            /* Old layout: container, row, and col */
            .container {
                display: flex;
                flex-direction: column;
                gap: var(--gap);
            }
            .row {
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
            }
            .col {
                flex: 1;
                min-width: 300px;
            }

            /* Canvas and preview styles */
            canvas {
                max-width: 100%;
                background-color: var(--bg-panel);
                border: var(--border-thickness) solid var(--border);
                display: block;
            }
            .canvas-container {
                max-width: 100%;
                background-color: var(--bg-panel);
                border: var(--border-thickness) solid var(--border);
                position: relative;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            textarea,
            input {
                background-color: var(--bg-panel);
                color: var(--text);
                border: var(--border-thickness) solid var(--border-input);
                border-radius: var(--border-radius);
                padding: 8px;
                width: 100%;
                box-sizing: border-box;
                font-family: monospace;
            }

            .code-editor {
                height: 400px;
                background-color: var(--bg-panel);
                border: var(--border-thickness) solid var(--border-input);
                border-radius: var(--border-radius);
                overflow: hidden;
            }
            .code-editor textarea {
                width: 100%;
                height: 100%;
                resize: none;
                border: none;
                padding: 8px;
                background-color: transparent;
                line-height: 1.5;
                tab-size: 2;
                font-family: monospace;
                color: var(--text);
            }

            button {
                background-color: var(--btn);
                color: var(--text);
                border: none;
                padding: 8px 16px;
                cursor: pointer;
                margin: 5px 0;
                border-radius: var(--border-radius);
                transition: all 0.2s ease;
            }
            button:hover {
                background-color: var(--btn-hover);
            }
            button:active {
                transform: scale(0.98);
            }
            button.active {
                background-color: var(--btn-active);
                color: var(--btn-active-text-color);
            }
            /* Removed the smaller style by not using the .small helper */
            button.small {
                padding: 8px 16px;
                font-size: 1em;
            }
            button.danger:hover {
                background-color: var(--btn-danger);
                color: var(--button-danger-text-color);
            }

            .console {
                background-color: var(--bg-console);
                color: var(--console-text);
                padding: var(--padding);
                font-family: monospace;
                height: 150px;
                overflow-y: auto;
                margin-top: 10px;
                white-space: pre-wrap;
                border-radius: var(--border-radius);
            }

            .control-section {
                background-color: var(--bg-panel);
                padding: var(--padding);
                border-radius: var(--border-radius);
                /* Adjusted margin so the bottom spacing is consistent */
                margin: var(--margin) 0 0 0;
            }
            .transform-controls {
                margin: var(--margin) 0;
                padding: var(--padding);
                background-color: var(--bg-panel);
                border-radius: var(--border-radius);
            }
            .var-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
                flex-wrap: wrap;
            }
            .var-name {
                width: 150px;
                flex-shrink: 0;
            }
            .var-input {
                flex: 1;
            }

            .save-slots {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin: var(--margin) 0;
            }
            .save-slot {
                background-color: var(--btn);
                padding: 8px;
                border-radius: var(--border-radius);
                cursor: pointer;
                flex: 1;
                min-width: 80px;
                text-align: center;
                transition: all 0.2s ease;
            }
            .save-slot:hover {
                background-color: var(--btn-hover);
            }
            .save-slot:active {
                transform: scale(0.98);
            }
            .save-slot.active {
                background-color: var(--btn-active);
                color: var(--background);
            }
            .checkbox-wrapper {
                display: flex;
                align-items: center;
                gap: 8px;
                white-space: nowrap;
                margin-right: 15px;
            }

            .history-controls {
                display: flex;
                gap: 5px;
            }
            .output-actions {
                display: flex;
                gap: 10px;
                padding: var(--padding);
                border: var(--border-thickness) solid var(--border);
                border-radius: var(--border-radius);
                margin: var(--margin) 0;
            }

            /* Custom Checkbox Styles */
            input[type="checkbox"] {
                /* Remove native appearance */
                appearance: none;
                -webkit-appearance: none;
                width: 20px;
                height: 20px;
                border: var(--border-thickness) solid var(--border);
                background-color: var(--bg-panel);
                border-radius: 4px;
                position: relative;
                cursor: pointer;
                transition: background-color 0.2s ease;
            }

            /* Change appearance on hover */
            input[type="checkbox"]:hover {
                background-color: var(--btn-hover);
            }

            /* When the checkbox is checked */
            input[type="checkbox"]:checked {
                background-color: var(--btn-active);
            }

            input[type="checkbox"]:checked::after {
                content: none;
            }

            /* Hide number input arrows in Chrome, Safari, Edge, Opera */
            input[type="number"]::-webkit-inner-spin-button,
            input[type="number"]::-webkit-outer-spin-button {
                -webkit-appearance: none;
                margin: 0;
            }

            /* Hide arrows in Firefox */
            input[type="number"] {
                -moz-appearance: textfield;
            }

            input[type="range"] {
                /* Use the default slider style with your CSS variable for the accent color */
                accent-color: var(--slider-color);
            }

            /* Fullscreen preview styles */
            .fullscreen-preview {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                cursor: pointer;
            }
            .fullscreen-preview canvas {
                max-width: 95vw;
                max-height: 95vh;
                object-fit: contain;
            }
            .exit-fullscreen {
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.5);
                color: white;
                border: none;
                border-radius: var(--border-radius);
                padding: 10px 15px;
                cursor: pointer;
            }
            .exit-fullscreen:hover {
                background: rgba(30, 30, 30, 0.8);
            }
        </style>
    </head>
    <body>
        <!-- Old layout: a container with a row of two columns -->
        <div class="container">
            <h1>GLSL Image Shader</h1>
            <div class="row">
                <div class="col">
                    <h2>Input</h2>
                    <div>
                        <!-- This is your local image button, now a CTA -->
                        <button id="loadImage">Load Image</button>

                        <!-- New Unload Image button, initially hidden -->
                        <button id="unloadImage" style="display: none;">Unload Image</button>

                        <!-- External image section: add class "border-active" to give it the border style initially -->
                        <div class="external-image">
                          <input
                            type="text"
                            id="externalImageUrl"
                            placeholder="Enter external image URL"
                          />
                          <button id="loadImageByUrl" type="button" class="border-active">
                            Load External Image
                          </button>
                        </div>

                    <!-- Moved Apply Shader button above the slot buttons -->
                    <h3>Shader Code</h3>
                    <div class="var-row">
                        <button id="updateShader" type="button">
                            Apply/Update Shader
                        </button>
                        <button id="toggleShader" type="button">
                            Toggle Shader
                        </button>
                        <button id="loadShader">Load Shader</button>
                        <button id="saveCurrentSlot">Save Current Slot</button>
                        <button id="pauseTime">Pause Time</button>
                        <div class="history-controls">
                            <button id="undoButton" title="Undo">↩</button>
                            <button id="redoButton" title="Redo">↪</button>
                        </div>
                        <input
                            type="file"
                            id="shaderInput"
                            accept=".glsl,.frag,.txt"
                            style="display: none"
                        />
                    </div>

                    <div class="save-slots">
                        <div class="save-slot" data-slot="1">Slot 1</div>
                        <div class="save-slot" data-slot="2">Slot 2</div>
                        <div class="save-slot" data-slot="3">Slot 3</div>
                        <div class="save-slot" data-slot="4">Slot 4</div>
                        <div class="save-slot" data-slot="5">Slot 5</div>
                    </div>

                    <div class="code-editor">
                        <textarea
                            id="shaderCode"
                            placeholder="Enter GLSL shader code here..."
                        ></textarea>
                    </div>

                    <div class="control-section">
                        <h3>Canvas Settings</h3>
                        <div class="var-row">
                            <span class="var-name">Background:</span>
                            <input
                                type="text"
                                id="canvasBackground"
                                value="#000000"
                                class="var-input"
                                placeholder="Hex color e.g. #000000"
                            />
                            <div
                                class="color-preview"
                                id="bgColorPreview"
                                style="background-color: #000000"
                            ></div>
                            <button id="applyBackground">Apply</button>
                        </div>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="transparentCanvas" />
                                <label for="transparentCanvas"
                                    >Transparent Canvas</label
                                >
                            </div>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Zoom:</span>
                            <input
                                type="range"
                                id="zoomLevel"
                                min="0.1"
                                max="5"
                                step="0.1"
                                value="1"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="zoomInput"
                                value="1"
                                min="0.1"
                                max="5"
                                step="0.1"
                                style="width: 60px"
                            />
                            <span id="zoomValue">1x</span>
                            <button id="resetZoom">Reset</button>
                        </div>
                    </div>

                    <div class="transform-controls">
                        <h3>Transform</h3>
                        <div class="var-row">
                            <span class="var-name">Canvas Position:</span>
                            <input
                                type="number"
                                id="canvasX"
                                placeholder="X"
                                min="0"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasY"
                                placeholder="Y"
                                min="0"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasWidth"
                                placeholder="Width"
                                min="1"
                                class="var-input"
                            />
                            <input
                                type="number"
                                id="canvasHeight"
                                placeholder="Height"
                                min="1"
                                class="var-input"
                            />
                            <button id="resetCanvas">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Aspect Ratio:</span>
                            <input
                                type="number"
                                id="aspectW"
                                placeholder="Width"
                                min="1"
                                value="16"
                                class="var-input"
                            />
                            <span>:</span>
                            <input
                                type="number"
                                id="aspectH"
                                placeholder="Height"
                                min="1"
                                value="9"
                                class="var-input"
                            />
                            <button id="applyAspect">Apply</button>
                            <button id="resetAspect">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Rotation:</span>
                            <div class="rotation-presets">
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="0"
                                >
                                    0°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="90"
                                >
                                    90°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="180"
                                >
                                    180°
                                </button>
                                <button
                                    type="button"
                                    class="rotation-preset"
                                    data-rotation="270"
                                >
                                    270°
                                </button>
                            </div>
                            <button id="resetRotation">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Mirror:</span>
                            <button id="mirrorX">X</button>
                            <button id="mirrorY">Y</button>
                            <button id="resetMirror">Reset</button>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <h2>Output</h2>
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="canvas"></canvas>
                    </div>

                    <div class="output-actions">
                        <button id="fullscreenPreview">
                            Full Screen Preview
                        </button>
                        <button id="resetAllParams" class="danger">
                            Reset All Parameters
                        </button>
                    </div>

                    <div class="control-section">
                        <h3>Export Image</h3>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="exportWithAlpha" />
                                <label for="exportWithAlpha">
                                    Export with Alpha
                                </label>
                            </div>
                        </div>
                        <div class="var-row">
                            <button id="savePNG">Save as PNG</button>
                            <button id="saveJPG">Save as JPG</button>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3>Export Animation</h3>
                        <div class="var-row">
                            <span class="var-name">FPS:</span>
                            <input
                                type="number"
                                id="exportFps"
                                min="1"
                                max="60"
                                value="30"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Bitrate (Mbps):</span>
                            <input
                                type="number"
                                id="exportBitrate"
                                min="1"
                                max="50"
                                value="5"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Duration (sec):</span>
                            <input
                                type="number"
                                id="animationDuration"
                                min="1"
                                value="5"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Start Time (sec):</span>
                            <input
                                type="number"
                                id="exportStartTime"
                                min="0"
                                value="0"
                                step="0.01"
                                class="var-input"
                            />
                        </div>
                        <div class="var-row">
                            <button id="exportMp4">Export as WebM</button>
                        </div>
                    </div>

                    <h3>Console</h3>
                    <div id="console" class="console"></div>
                </div>
            </div>
        </div>

        <!-- Fullscreen preview container (hidden by default) -->
        <div
            id="fullscreenContainer"
            style="display: none"
            class="fullscreen-preview"
        >
            <canvas id="fullscreenCanvas"></canvas>
            <button class="exit-fullscreen">Exit Full Screen (ESC)</button>
            <button
                id="fullscreenPauseTime"
                class="exit-fullscreen"
                style="right: 180px"
            >
                Pause Animation
            </button>
        </div>

        <!-- Shaders -->
        <script type="x-shader/x-fragment" id="defaultFragmentShader">
            precision mediump float;
            varying vec2 v_texcoord;
            uniform sampler2D tex;
            uniform float time;
            void main() {
              vec4 color = texture2D(tex, v_texcoord);
              gl_FragColor = color;
            }
        </script>
        <script type="x-shader/x-vertex" id="vertexShader">
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
              gl_Position = vec4(a_position, 0.0, 1.0);
              v_texcoord = a_texcoord;
            }
        </script>

        <script>
            let shaderActive = true; // global flag for shader state

            document
                .getElementById("toggleShader")
                .addEventListener("click", () => {
                    shaderActive = !shaderActive;
                    if (shaderActive) {
                        log("Shader toggled on.");
                        // Compile the custom shader (using code in the text area)
                        compileShader();
                        render();
                    } else {
                        log("Shader toggled off.");
                        // Compile the default/pass-through shader
                        compileDefaultShader();
                        render();
                    }
                });

            function compileDefaultShader() {
                const vertexSource =
                    document.getElementById("vertexShader").textContent;
                const defaultFragmentSource = document.getElementById(
                    "defaultFragmentShader",
                ).textContent;
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    vertexSource,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    defaultFragmentSource,
                );

                const newProgram = createProgram(
                    gl,
                    vertexShader,
                    fragmentShader,
                );
                if (!newProgram) return;

                // Delete the previous program if necessary and update the current one.
                if (program) gl.deleteProgram(program);
                program = newProgram;
                gl.useProgram(program);
                log("Default shader compiled successfully");
            }
        </script>

        <!-- Main WebGL and controls script -->
        <script>
            // ------------------------------ WebGL / Controls Script
            const $ = document.getElementById.bind(document);
            const canvas = $("canvas");
            const fsCanvas = $("fullscreenCanvas");
            const canvasContainer = $("canvasContainer");
            const fsContainer = $("fullscreenContainer");
            const gl = canvas.getContext("webgl");
            let fsGl = null;
            const consoleEl = $("console");
            const codeTextarea = $("shaderCode");
            const zoomSlider = $("zoomLevel");
            const zoomInput = $("zoomInput");
            const zoomValue = $("zoomValue");
            const bgColorInput = $("canvasBackground");
            const bgColorPreview = $("bgColorPreview");
            const transCanvas = $("transparentCanvas");
            const exportAlpha = $("exportWithAlpha");

            let image = null,
                imageTexture = null,
                program = null;
            let startTime = Date.now(),
                pausedTime = null;
            let animFrame = null,
                fsAnimFrame = null;
            let posBuffer = null,
                texCoordBuffer = null;
            let timePaused = false,
                fsTimePaused = false;

            // Transform state
            let rotation = 0,
                mirrorX = false,
                mirrorY = false;
            let canvasState = { x: 0, y: 0, width: 0, height: 0 };
            let zoomLevel = 1,
                bgColor = "#000000";
            let useTransparent = false,
                useExportAlpha = false;

            // History state for undo/redo
            const maxHistory = 50;
            let history = [],
                historyIndex = -1;

            document
                .getElementById("loadImageByUrl")
                .addEventListener("click", () => {
                    const url = document
                        .getElementById("externalImageUrl")
                        .value.trim();
                    if (!url) {
                        log("Please enter an external image URL.", "error");
                        return;
                    }

                    const img = new Image();
                    // Allow cross-origin loading if the server supports it.
                    img.crossOrigin = "Anonymous";
                    // For example, inside your onload callback for image loading:
                    img.onload = () => {
                      image = img;
                      canvas.width = img.width;
                      canvas.height = img.height;

                      canvasState = {
                        x: 0,
                        y: 0,
                        width: img.width,
                        height: img.height,
                      };

                      updateCanvasUI();
                      log("Image loaded from external URL");

                      createImageTexture();
                      initBuffers();
                      updateCanvasDisplay();
                      startRendering();
                      saveToHistory();

                      // Update buttons:
                      // Change "Load Image" (formerly local image button) text to "Load New Image"
                      document.getElementById("loadImage").textContent = "Load New Image";
                      // Unhide the new "Unload Image" button
                      document.getElementById("unloadImage").style.display = "inline-block";
                      // Remove the 'border-active' style from the external button (if you want)
                      document.getElementById("loadImageByUrl").classList.remove("border-active");
                    };
                    document.getElementById("unloadImage").addEventListener("click", () => {
                      // Clear the image and related state.
                      image = null;
                      // Optionally, clear the canvas or set it to a default state.
                      canvas.width = 0;
                      canvas.height = 0;
                      // Log the action.
                      log("Image unloaded.");

                      // Revert button texts and styles:
                      // Change "Load New Image" back to "Load Image"
                      document.getElementById("loadImage").textContent = "Load Image";
                      // Hide the "Unload Image" button.
                      document.getElementById("unloadImage").style.display = "none";
                      // Add back the border-active class to the external image button.
                      document.getElementById("loadImageByUrl").classList.add("border-active");

                      // If you have other state cleanups (e.g., resetting the texture), perform them here.
                      // You may also want to re-render the UI to show an empty canvas.
                    });
                    img.onerror = () => {
                        log(`Error loading image from URL: ${url}`, "error");
                    };
                    img.src = url;
                });

            // Zoom stuff
            function updateSliderAppearance() {
                // Update the synced values
                zoomLevel = parseFloat(zoomSlider.value);
                zoomInput.value = zoomLevel;
                zoomValue.textContent = `${zoomLevel.toFixed(1)}x`;

                // Get the raw min, max, and current value
                let min = parseFloat(zoomSlider.min);
                let max = parseFloat(zoomSlider.max);
                let value = zoomLevel;

                // Measure the slider's visible width
                const sliderWidth = zoomSlider.clientWidth;
                // The thumb size must match the CSS thumb width (20px in your case)
                const thumbSize = 20;
                // The thumb center position is computed as:
                //   (sliderWidth - thumbSize) * (fraction of progress) + half the thumb
                const centerPosition =
                    ((value - min) / (max - min)) * (sliderWidth - thumbSize) +
                    thumbSize / 2;
                // Convert that to a percentage relative to the slider's width
                const centerPercentage = (centerPosition / sliderWidth) * 100;

                // Now set the background gradient:
                //   From 0% to the computed percentage, use the active (filled) color;
                //   from that percentage to 100%, use the base slider color.
                zoomSlider.style.background = `linear-gradient(
                to right,
                var(--btn-active) 0%,
                var(--btn-active) ${centerPercentage}%,
                var(--slider-color) ${centerPercentage}%,
                var(--slider-color) 100%
              )`;

                updateCanvasDisplay();
            }

            // Save slots
            const saveSlots = document.querySelectorAll(".save-slot");
            let activeSlot = null;

            function saveToHistory() {
                const newState = {
                    shaderCode: codeTextarea.value,
                    rotation,
                    mirrorX,
                    mirrorY,
                    canvas: { ...canvasState },
                    bgColor,
                    useTransparent,
                };

                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }

                history.push(newState);
                historyIndex = history.length - 1;

                if (history.length > maxHistory) {
                    history.shift();
                    historyIndex--;
                }

                updateHistoryBtns();
            }

            function updateHistoryBtns() {
                $("undoButton").disabled = historyIndex <= 0;
                $("redoButton").disabled = historyIndex >= history.length - 1;
            }

            $("undoButton").addEventListener("click", () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            $("redoButton").addEventListener("click", () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            function applyHistoryState(state) {
                codeTextarea.value = state.shaderCode;
                rotation = state.rotation;
                mirrorX = state.mirrorX;
                mirrorY = state.mirrorY;
                canvasState = { ...state.canvas };
                bgColor = state.bgColor;
                useTransparent = state.useTransparent;
                transCanvas.checked = useTransparent;
                bgColorInput.value = bgColor;
                bgColorPreview.style.backgroundColor = bgColor;

                updateRotationUI();
                updateCanvasUI();
                compileShader();
                updateTransform();
                updateCanvasDisplay();
            }

            if (localStorage.getItem("glsl-shader")) {
                codeTextarea.value = localStorage.getItem("glsl-shader");
            }

            saveSlots.forEach((slot) => {
                const slotNum = slot.dataset.slot;
                // Set initial text and state.
                slot.textContent = `Slot ${slotNum}`;
                slot.dataset.state = "default"; // possible states: default, confirm_save, confirm_load, confirm_clear, finish
                let timer = null;

                // Utility: Reset the slot to default state.
                function resetSlot() {
                    slot.textContent = `Slot ${slotNum}`;
                    slot.dataset.state = "default";
                    timer = null;
                }

                // Left-click handler
                slot.addEventListener("click", (e) => {
                    e.preventDefault();

                    // If in clear-confirmation state, a left-click aborts the clear.
                    if (slot.dataset.state === "confirm_clear") {
                        if (timer) clearTimeout(timer);
                        slot.textContent = "aborted";
                        slot.dataset.state = "finish";
                        timer = setTimeout(resetSlot, 1000);
                        return;
                    }

                    // In default state, start a save/load confirmation.
                    if (slot.dataset.state === "default") {
                        // If a saved shader exists, ask for load confirmation.
                        if (
                            localStorage.getItem(`glsl-shader-slot-${slotNum}`)
                        ) {
                            slot.textContent = "load?";
                            slot.dataset.state = "confirm_load";
                        } else {
                            // Otherwise, ask for save confirmation.
                            slot.textContent = "save?";
                            slot.dataset.state = "confirm_save";
                        }
                        timer = setTimeout(resetSlot, 3000);
                        return;
                    }

                    // Confirm the save action on a second left-click.
                    if (slot.dataset.state === "confirm_save") {
                        if (timer) clearTimeout(timer);
                        localStorage.setItem(
                            `glsl-shader-slot-${slotNum}`,
                            codeTextarea.value,
                        );
                        slot.textContent = "saved!";
                        slot.dataset.state = "finish";
                        // Optionally mark slot as active (if desired, e.g. add a class).
                        timer = setTimeout(resetSlot, 1000);
                        return;
                    }

                    // Confirm the load action on a second left-click.
                    // In the left-click handler for a slot...
                    if (slot.dataset.state === "confirm_load") {
                        if (timer) clearTimeout(timer);
                        const savedContent = localStorage.getItem(
                            `glsl-shader-slot-${slotNum}`,
                        );
                        if (savedContent) {
                            codeTextarea.value = savedContent;
                        }
                        slot.textContent = "loaded!";
                        // Remove active styling from all slots...
                        saveSlots.forEach((s) => s.classList.remove("active"));
                        // Mark this one as active.
                        slot.classList.add("active");
                        activeSlot = slotNum;
                        slot.dataset.state = "finish";
                        timer = setTimeout(resetSlot, 1000);
                        return;
                    }
                });

                // Right-click (contextmenu) handler
                slot.addEventListener("contextmenu", (e) => {
                    e.preventDefault();

                    // If a left-click confirmation (save/load) is in progress, abort it.
                    if (
                        slot.dataset.state === "confirm_save" ||
                        slot.dataset.state === "confirm_load"
                    ) {
                        if (timer) clearTimeout(timer);
                        slot.textContent = "aborted";
                        slot.dataset.state = "finish";
                        timer = setTimeout(resetSlot, 1000);
                        return;
                    }

                    // In default state, start the clear-confirmation process.
                    if (slot.dataset.state === "default") {
                        slot.textContent = "clear?";
                        slot.dataset.state = "confirm_clear";
                        timer = setTimeout(resetSlot, 3000);
                        return;
                    }

                    // Confirm clear on second right-click.
                    if (slot.dataset.state === "confirm_clear") {
                        if (timer) clearTimeout(timer);
                        localStorage.removeItem(`glsl-shader-slot-${slotNum}`);
                        slot.textContent = "cleared!";
                        slot.dataset.state = "finish";
                        // Remove the active visual state if this slot was active.
                        slot.classList.remove("active");
                        // Update the global active slot variable if necessary.
                        if (activeSlot === slotNum) {
                            activeSlot = null;
                        }
                        timer = setTimeout(resetSlot, 1000);
                        return;
                    }
                });
            });

            zoomSlider.addEventListener("input", updateSliderAppearance);
            zoomInput.addEventListener("input", () => {
                zoomLevel = parseFloat(zoomInput.value);
                zoomSlider.value = zoomLevel;
                updateSliderAppearance();
            });

            zoomInput.addEventListener("input", () => {
                zoomLevel = parseFloat(zoomInput.value);
                zoomSlider.value = zoomLevel;
                zoomValue.textContent = `${zoomLevel.toFixed(1)}x`;
                updateCanvasDisplay();
            });

            $("resetZoom").addEventListener("click", () => {
                zoomLevel = 1;
                zoomSlider.value = 1;
                zoomInput.value = 1;
                zoomValue.textContent = "1x";
                updateSliderAppearance();
            });

            $("resetAllParams").addEventListener("click", () => {
                rotation = 0;
                mirrorX = mirrorY = false;
                if (image) {
                    canvasState = {
                        x: 0,
                        y: 0,
                        width: image.width,
                        height: image.height,
                    };
                }

                bgColor = "#000000";
                useTransparent = false;
                bgColorInput.value = bgColor;
                bgColorPreview.style.backgroundColor = bgColor;
                transCanvas.checked = false;

                zoomLevel = 1;
                zoomSlider.value = 1;
                zoomInput.value = 1;
                zoomValue.textContent = "1x";

                updateRotationUI();
                updateCanvasUI();
                updateTransform();
                updateCanvasDisplay();
                saveToHistory();
                log("All parameters reset to defaults");
            });

            bgColorInput.addEventListener("input", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColorPreview.style.backgroundColor = color;
                }
            });

            $("applyBackground").addEventListener("click", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColor = color;
                    updateCanvasDisplay();
                    log(`Canvas background set to ${color}`);
                    saveToHistory();
                } else {
                    log(
                        "Invalid hex color format. Use #RRGGBB format.",
                        "error",
                    );
                }
            });

            transCanvas.addEventListener("change", () => {
                useTransparent = transCanvas.checked;
                updateCanvasDisplay();
                render();
                saveToHistory();
            });

            exportAlpha.addEventListener("change", () => {
                useExportAlpha = exportAlpha.checked;
            });

            $("loadImage").addEventListener("click", () =>
                $("imageInput").click(),
            );
            $("imageInput").addEventListener("change", (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        const img = new Image();
                        img.onload = () => {
                            image = img;
                            canvas.width = img.width;
                            canvas.height = img.height;

                            canvasState = {
                                x: 0,
                                y: 0,
                                width: img.width,
                                height: img.height,
                            };
                            updateCanvasUI();
                            log(
                                `Image loaded: ${file.name} (${img.width}x${img.height})`,
                            );

                            createImageTexture();
                            initBuffers();
                            updateCanvasDisplay();
                            startRendering();
                            saveToHistory();
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            $("loadShader").addEventListener("click", () =>
                $("shaderInput").click(),
            );
            $("shaderInput").addEventListener("change", (e) => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                        codeTextarea.value = evt.target.result;
                        log(`Shader loaded: ${file.name}`);
                        saveToHistory();
                    };
                    reader.readAsText(file);
                }
            });

            $("saveCurrentSlot").addEventListener("click", () => {
                if (activeSlot) {
                    localStorage.setItem(
                        `glsl-shader-slot-${activeSlot}`,
                        codeTextarea.value,
                    );
                    log(`Saved shader to slot ${activeSlot}`);
                } else {
                    localStorage.setItem("glsl-shader", codeTextarea.value);
                    log("No slot selected. Shader saved to general storage.");
                }
            });

            $("pauseTime").addEventListener("click", () => {
                timePaused = !timePaused;

                if (timePaused) {
                    pausedTime = (Date.now() - startTime) / 1000.0;
                    $("pauseTime").classList.add("active");
                    $("pauseTime").textContent = "Resume Time";
                } else {
                    pausedTime = null;
                    startTime = Date.now();
                    $("pauseTime").classList.remove("active");
                    $("pauseTime").textContent = "Pause Time";
                }

                log(`Time ${timePaused ? "paused" : "resumed"}`);
            });

            $("fullscreenPauseTime").addEventListener("click", () => {
                fsTimePaused = !fsTimePaused;
                $("fullscreenPauseTime").textContent = fsTimePaused
                    ? "Resume Animation"
                    : "Pause Animation";

                if (fsGl) {
                    if (fsAnimFrame) cancelAnimationFrame(fsAnimFrame);
                    if (!fsTimePaused) {
                        animateFullscreen();
                    } else {
                        renderFullscreen();
                    }
                }
            });

            // Update the shader (recompile/apply shader) when clicking the Update Shader button.
            document
                .getElementById("updateShader")
                .addEventListener("click", () => {
                    compileShader();
                    render();
                    saveToHistory();
                    log("Shader updated!");
                });

            $("savePNG").addEventListener("click", () => saveImage("png"));
            $("saveJPG").addEventListener("click", () => saveImage("jpeg"));
            $("exportMp4").addEventListener("click", () =>
                exportAnimation("webm"),
            );

            document.querySelectorAll(".rotation-preset").forEach((preset) => {
                preset.addEventListener("click", () => {
                    rotation = parseInt(preset.dataset.rotation);
                    updateRotationUI();
                    updateTransform();
                    saveToHistory();
                });
            });

            function updateRotationUI() {
                document
                    .querySelectorAll(".rotation-preset")
                    .forEach((preset) => {
                        if (parseInt(preset.dataset.rotation) === rotation) {
                            preset.classList.add("active");
                        } else {
                            preset.classList.remove("active");
                        }
                    });
            }

            function updateCanvasUI() {
                $("canvasX").value = canvasState.x;
                $("canvasY").value = canvasState.y;
                $("canvasWidth").value = canvasState.width;
                $("canvasHeight").value = canvasState.height;
            }

            $("resetRotation").addEventListener("click", () => {
                rotation = 0;
                updateRotationUI();
                updateTransform();
                saveToHistory();
            });

            $("resetMirror").addEventListener("click", () => {
                mirrorX = mirrorY = false;
                updateTransform();
                saveToHistory();
            });

            $("resetCanvas").addEventListener("click", () => {
                if (image) {
                    canvasState = {
                        x: 0,
                        y: 0,
                        width: image.width,
                        height: image.height,
                    };
                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            $("resetAspect").addEventListener("click", () => {
                $("aspectW").value = 16;
                $("aspectH").value = 9;
            });

            $("mirrorX").addEventListener("click", () => {
                mirrorX = !mirrorX;
                $("mirrorX").classList.toggle("active", mirrorX);
                updateTransform();
                saveToHistory();
            });

            $("mirrorY").addEventListener("click", () => {
                mirrorY = !mirrorY;
                $("mirrorY").classList.toggle("active", mirrorY);
                updateTransform();
                saveToHistory();
            });

            $("applyAspect").addEventListener("click", () => {
                const aspectW = parseFloat($("aspectW").value) || 16;
                const aspectH = parseFloat($("aspectH").value) || 9;

                if (image) {
                    const targetRatio = aspectW / aspectH;
                    const imgRatio = canvasState.width / canvasState.height;

                    if (imgRatio > targetRatio) {
                        const newWidth = canvasState.height * targetRatio;
                        const deltaX = (canvasState.width - newWidth) / 2;
                        canvasState.x += deltaX;
                        canvasState.width = newWidth;
                    } else {
                        const newHeight = canvasState.width / targetRatio;
                        const deltaY = (canvasState.height - newHeight) / 2;
                        canvasState.y += deltaY;
                        canvasState.height = newHeight;
                    }

                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            $("fullscreenPreview").addEventListener(
                "click",
                openFullscreenPreview,
            );

            function openFullscreenPreview() {
                if (!image) return;

                fsContainer.style.display = "flex";
                fsTimePaused = false;
                $("fullscreenPauseTime").textContent = "Pause Animation";

                fsCanvas.width = canvas.width;
                fsCanvas.height = canvas.height;

                if (!fsGl) {
                    fsGl = fsCanvas.getContext("webgl");
                    if (!fsGl) {
                        log(
                            "Failed to initialize WebGL for fullscreen preview",
                            "error",
                        );
                        return;
                    }
                }

                setupFullscreenCanvas();
                animateFullscreen();
            }

            function animateFullscreen() {
                if (fsTimePaused) return;
                renderFullscreen();
                fsAnimFrame = requestAnimationFrame(animateFullscreen);
            }

            function setupFullscreenCanvas() {
                const vertexShader = createShader(
                    fsGl,
                    fsGl.VERTEX_SHADER,
                    $("vertexShader").textContent,
                );
                const fragmentShader = createShader(
                    fsGl,
                    fsGl.FRAGMENT_SHADER,
                    codeTextarea.value,
                );

                if (!vertexShader || !fragmentShader) return;

                const fsProgram = createProgram(
                    fsGl,
                    vertexShader,
                    fragmentShader,
                );
                if (!fsProgram) return;

                fsGl.useProgram(fsProgram);

                const posBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.bufferData(
                    fsGl.ARRAY_BUFFER,
                    new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                    fsGl.STATIC_DRAW,
                );

                const texCoords = getTransformedTexCoords();
                const texBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.bufferData(
                    fsGl.ARRAY_BUFFER,
                    new Float32Array(texCoords),
                    fsGl.STATIC_DRAW,
                );

                const posLoc = fsGl.getAttribLocation(fsProgram, "a_position");
                const texLoc = fsGl.getAttribLocation(fsProgram, "a_texcoord");

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.enableVertexAttribArray(posLoc);
                fsGl.vertexAttribPointer(posLoc, 2, fsGl.FLOAT, false, 0, 0);

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.enableVertexAttribArray(texLoc);
                fsGl.vertexAttribPointer(texLoc, 2, fsGl.FLOAT, false, 0, 0);

                const texture = fsGl.createTexture();
                fsGl.bindTexture(fsGl.TEXTURE_2D, texture);

                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_WRAP_S,
                    fsGl.CLAMP_TO_EDGE,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_WRAP_T,
                    fsGl.CLAMP_TO_EDGE,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_MIN_FILTER,
                    fsGl.LINEAR,
                );
                fsGl.texParameteri(
                    fsGl.TEXTURE_2D,
                    fsGl.TEXTURE_MAG_FILTER,
                    fsGl.LINEAR,
                );

                fsGl.texImage2D(
                    fsGl.TEXTURE_2D,
                    0,
                    fsGl.RGBA,
                    fsGl.RGBA,
                    fsGl.UNSIGNED_BYTE,
                    image,
                );

                const texUnitLoc = fsGl.getUniformLocation(fsProgram, "tex");
                fsGl.uniform1i(texUnitLoc, 0);

                const timeLoc = fsGl.getUniformLocation(fsProgram, "time");
                if (timeLoc) {
                    if (timePaused && pausedTime !== null) {
                        fsGl.uniform1f(timeLoc, pausedTime);
                    } else {
                        fsGl.uniform1f(
                            timeLoc,
                            (Date.now() - startTime) / 1000.0,
                        );
                    }
                }
            }

            function renderFullscreen() {
                if (!fsGl) return;

                fsGl.viewport(0, 0, fsCanvas.width, fsCanvas.height);

                let r = 0,
                    g = 0,
                    b = 0,
                    a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }

                fsGl.clearColor(r, g, b, a);
                fsGl.clear(fsGl.COLOR_BUFFER_BIT);

                const program = fsGl.getParameter(fsGl.CURRENT_PROGRAM);
                const timeLoc = fsGl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (fsTimePaused) {
                        const currentTime = fsGl.getUniform(program, timeLoc);
                        fsGl.uniform1f(timeLoc, currentTime);
                    } else if (timePaused && pausedTime !== null) {
                        fsGl.uniform1f(timeLoc, pausedTime);
                    } else {
                        fsGl.uniform1f(
                            timeLoc,
                            (Date.now() - startTime) / 1000.0,
                        );
                    }
                }

                fsGl.drawArrays(fsGl.TRIANGLE_STRIP, 0, 4);
            }

            function closeFullscreenPreview() {
                fsContainer.style.display = "none";
                if (fsAnimFrame) {
                    cancelAnimationFrame(fsAnimFrame);
                    fsAnimFrame = null;
                }
            }

            document
                .querySelector(".exit-fullscreen")
                .addEventListener("click", closeFullscreenPreview);
            fsContainer.addEventListener("click", (e) => {
                if (e.target === fsContainer) closeFullscreenPreview();
            });

            document.addEventListener("keydown", (e) => {
                if (
                    e.key === "Escape" &&
                    fsContainer.style.display !== "none"
                ) {
                    closeFullscreenPreview();
                }
            });

            ["canvasX", "canvasY", "canvasWidth", "canvasHeight"].forEach(
                (id) => {
                    $(id).addEventListener("change", () => {
                        canvasState.x = parseFloat($("canvasX").value) || 0;
                        canvasState.y = parseFloat($("canvasY").value) || 0;
                        canvasState.width =
                            parseFloat($("canvasWidth").value) ||
                            image?.width ||
                            0;
                        canvasState.height =
                            parseFloat($("canvasHeight").value) ||
                            image?.height ||
                            0;
                        updateTransform();
                        saveToHistory();
                    });
                },
            );

            if (!gl) {
                log("WebGL not supported!", "error");
            } else {
                log("WebGL initialized successfully");
                initWebGL();
            }

            function initWebGL() {
                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    $("vertexShader").textContent,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    $("defaultFragmentShader").textContent,
                );
                program = createProgram(gl, vertexShader, fragmentShader);
                initBuffers();
                saveToHistory();
            }

            function initBuffers() {
                posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]),
                    gl.STATIC_DRAW,
                );

                texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]),
                    gl.STATIC_DRAW,
                );
            }

            function getTransformedTexCoords() {
                let texCoords;
                switch (rotation % 360) {
                    case 0:
                        texCoords = [0, 1, 1, 1, 0, 0, 1, 0];
                        break;
                    case 90:
                        texCoords = [0, 0, 0, 1, 1, 0, 1, 1];
                        break;
                    case 180:
                        texCoords = [1, 0, 0, 0, 1, 1, 0, 1];
                        break;
                    case 270:
                        texCoords = [1, 1, 1, 0, 0, 1, 0, 0];
                        break;
                    default:
                        texCoords = [0, 1, 1, 1, 0, 0, 1, 0];
                }
                if (mirrorX) {
                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }
                if (mirrorY) {
                    for (let i = 1; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }
                if (image && image.width > 0 && image.height > 0) {
                    const xScale = canvasState.width / image.width;
                    const yScale = canvasState.height / image.height;
                    const xOffset = canvasState.x / image.width;
                    const yOffset = canvasState.y / image.height;

                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = texCoords[i] * xScale + xOffset;
                        texCoords[i + 1] = texCoords[i + 1] * yScale + yOffset;
                    }
                }
                return texCoords;
            }

            function createShader(ctx, type, source) {
                const shader = ctx.createShader(type);
                ctx.shaderSource(shader, source);
                ctx.compileShader(shader);

                if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
                    log(
                        `Error compiling shader: ${ctx.getShaderInfoLog(
                            shader,
                        )}`,
                        "error",
                    );
                    ctx.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            function createProgram(ctx, vertexShader, fragmentShader) {
                const prog = ctx.createProgram();
                ctx.attachShader(prog, vertexShader);
                ctx.attachShader(prog, fragmentShader);
                ctx.linkProgram(prog);

                if (!ctx.getProgramParameter(prog, ctx.LINK_STATUS)) {
                    log(
                        `Error linking program: ${ctx.getProgramInfoLog(prog)}`,
                        "error",
                    );
                    ctx.deleteProgram(prog);
                    return null;
                }

                return prog;
            }

            function createImageTexture() {
                if (!image) return;

                if (imageTexture) gl.deleteTexture(imageTexture);

                imageTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_WRAP_S,
                    gl.CLAMP_TO_EDGE,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_WRAP_T,
                    gl.CLAMP_TO_EDGE,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MIN_FILTER,
                    gl.LINEAR,
                );
                gl.texParameteri(
                    gl.TEXTURE_2D,
                    gl.TEXTURE_MAG_FILTER,
                    gl.LINEAR,
                );

                gl.texImage2D(
                    gl.TEXTURE_2D,
                    0,
                    gl.RGBA,
                    gl.RGBA,
                    gl.UNSIGNED_BYTE,
                    image,
                );

                canvas.width = image.width;
                canvas.height = image.height;

                canvasState = {
                    x: 0,
                    y: 0,
                    width: image.width,
                    height: image.height,
                };
            }

            function compileShader() {
                const fragmentSource = codeTextarea.value.trim();
                if (!fragmentSource) {
                    log("Shader code is empty!", "error");
                    return;
                }

                const vertexShader = createShader(
                    gl,
                    gl.VERTEX_SHADER,
                    $("vertexShader").textContent,
                );
                const fragmentShader = createShader(
                    gl,
                    gl.FRAGMENT_SHADER,
                    fragmentSource,
                );
                if (!fragmentShader) return;

                const newProgram = createProgram(
                    gl,
                    vertexShader,
                    fragmentShader,
                );
                if (!newProgram) return;

                if (program) gl.deleteProgram(program);
                program = newProgram;
                gl.useProgram(program);

                log("Shader compiled successfully");

                startTime = Date.now();
                pausedTime = null;
                timePaused = false;
                $("pauseTime").classList.remove("active");
                $("pauseTime").textContent = "Pause Time";
            }

            function updateTransform() {
                if (!image) return;

                if (rotation % 180 === 90) {
                    canvas.width = canvasState.height;
                    canvas.height = canvasState.width;
                } else {
                    canvas.width = canvasState.width;
                    canvas.height = canvasState.height;
                }

                const texCoords = getTransformedTexCoords();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(
                    gl.ARRAY_BUFFER,
                    new Float32Array(texCoords),
                    gl.STATIC_DRAW,
                );

                $("mirrorX").classList.toggle("active", mirrorX);
                $("mirrorY").classList.toggle("active", mirrorY);

                updateCanvasDisplay();
                render();
                log(
                    `Transform updated: rotation=${rotation}°, mirrorX=${mirrorX}, mirrorY=${mirrorY}, canvas=(${canvasState.x},${canvasState.y},${canvasState.width},${canvasState.height})`,
                );
            }

            function updateCanvasDisplay() {
                if (useTransparent) {
                    canvasContainer.style.backgroundColor = "transparent";
                    canvasContainer.style.backgroundImage =
                        "linear-gradient(45deg, #aaa 25%, transparent 25%), linear-gradient(-45deg, #aaa 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #aaa 75%), linear-gradient(-45deg, transparent 75%, #aaa 75%)";
                    canvasContainer.style.backgroundSize = "20px 20px";
                    canvasContainer.style.backgroundPosition =
                        "0 0, 0 10px, 10px -10px, -10px 0px";
                } else {
                    canvasContainer.style.backgroundColor = bgColor;
                    canvasContainer.style.backgroundImage = "none";
                }

                canvas.style.transformOrigin = "center center";
                canvas.style.transform = `scale(${zoomLevel})`;
            }

            function startRendering() {
                if (animFrame) cancelAnimationFrame(animFrame);
                function animate() {
                    render();
                    animFrame = requestAnimationFrame(animate);
                }
                animate();
            }

            function stopRendering() {
                if (animFrame) {
                    cancelAnimationFrame(animFrame);
                    animFrame = null;
                }
            }

            function render() {
                if (!gl || !program || !imageTexture) return;

                gl.viewport(0, 0, canvas.width, canvas.height);

                let r = 0,
                    g = 0,
                    b = 0,
                    a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }

                gl.clearColor(r, g, b, a);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);

                const posLoc = gl.getAttribLocation(program, "a_position");
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                const texLoc = gl.getAttribLocation(program, "a_texcoord");
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

                const texLocation = gl.getUniformLocation(program, "tex");
                gl.uniform1i(texLocation, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                const timeLoc = gl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (timePaused && pausedTime !== null) {
                        gl.uniform1f(timeLoc, pausedTime);
                    } else {
                        gl.uniform1f(
                            timeLoc,
                            (Date.now() - startTime) / 1000.0,
                        );
                    }
                }

                if (useTransparent) {
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.disable(gl.BLEND);
                }

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            function saveImage(type) {
                if (!canvas) return;
                try {
                    render();
                    gl.finish();

                    const mimeType =
                        type === "png" ? "image/png" : "image/jpeg";
                    const quality = type === "png" ? undefined : 0.9;

                    const tempCanvas = document.createElement("canvas");
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext("2d", {
                        alpha: useExportAlpha,
                    });

                    if (!useExportAlpha) {
                        tempCtx.fillStyle = bgColor;
                        tempCtx.fillRect(
                            0,
                            0,
                            tempCanvas.width,
                            tempCanvas.height,
                        );
                    }

                    tempCtx.drawImage(canvas, 0, 0);

                    const imageData = tempCanvas.toDataURL(mimeType, quality);

                    const link = document.createElement("a");
                    link.download = `shader_output.${
                        type === "png" ? "png" : "jpg"
                    }`;
                    link.href = imageData;
                    link.click();

                    log(`Image saved as ${type.toUpperCase()}`);
                } catch (error) {
                    log(`Error saving image: ${error}`, "error");
                }
            }

            function exportAnimation(type) {
                if (!canvas) {
                    log("No canvas to export!", "error");
                    return;
                }
                if (type === "webm") {
                    try {
                        const duration =
                            parseFloat($("animationDuration").value) || 5;
                        const fps = parseInt($("exportFps").value) || 30;
                        const startTime =
                            parseFloat($("exportStartTime").value) || 0;
                        const bitrate = parseInt($("exportBitrate").value) || 5;

                        log(
                            `Starting animation export: ${
                                duration * fps
                            } frames at ${fps} fps, starting at ${startTime}s...`,
                        );

                        timePaused = true;
                        pausedTime = startTime;

                        const stream = canvas.captureStream(fps);
                        const recorder = new MediaRecorder(stream, {
                            mimeType: "video/webm",
                            videoBitsPerSecond: bitrate * 1000000,
                        });

                        const chunks = [];
                        recorder.ondataavailable = (e) => chunks.push(e.data);
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, {
                                type: "video/webm",
                            });
                            const url = URL.createObjectURL(blob);

                            const link = document.createElement("a");
                            link.href = url;
                            link.download = "shader_animation.webm";
                            link.click();

                            log("Animation exported as WebM");
                            log(`Download links: [WebM](${url})`);

                            timePaused = false;
                            startTime = Date.now();
                            log("Export complete!");
                        };

                        recorder.start();

                        let currentTime = startTime;
                        const endTime = startTime + duration;
                        const frameInterval = 1000 / fps;

                        function renderFrame() {
                            if (currentTime >= endTime) {
                                recorder.stop();
                                return;
                            }

                            pausedTime = currentTime;
                            render();
                            currentTime += frameInterval / 1000;
                            setTimeout(renderFrame, frameInterval);
                        }

                        renderFrame();
                    } catch (error) {
                        log(`Error exporting animation: ${error}`, "error");
                        timePaused = false;
                    }
                }
            }

            function log(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                const formatted = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

                console[type === "error" ? "error" : "log"](message);

                consoleEl.innerHTML += formatted + "\n";
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }

            startRendering();
            updateRotationUI();
            updateHistoryBtns();
        </script>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const zoomSlider = document.getElementById("zoomLevel");
                function updateSliderBackground() {
                    const min = parseFloat(zoomSlider.min) || 0;
                    const max = parseFloat(zoomSlider.max) || 100;
                    const value = parseFloat(zoomSlider.value);
                    const percentage = ((value - min) * 100) / (max - min);
                    zoomSlider.style.background = `linear-gradient(to right, var(--slider-color) ${percentage}%, #444 ${percentage}%)`;
                }
                updateSliderBackground();
                zoomSlider.addEventListener("input", updateSliderBackground);
            });
        </script>
    </body>
</html>
