<!doctype html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>GLSL Image Shader</title>
        <style>
            :root {
                --bg-dark: #222;
                --bg-panel: #333;
                --bg-console: #111;
                --border: #444;
                --border-input: #555;
                --text: #eee;
                --btn: #444;
                --btn-hover: #555;
                --btn-active: #66a;
                --btn-danger: #933;
                --console-text: #0f0;
                --gap: 15px;
            }

            body {
                background-color: var(--bg-dark);
                color: var(--text);
                font-family: sans-serif;
                margin: 0;
                padding: 20px;
            }

            .container {
                display: flex;
                flex-direction: column;
                gap: var(--gap);
            }

            .row {
                display: flex;
                gap: 20px;
                flex-wrap: wrap;
            }

            .col {
                flex: 1;
                min-width: 300px;
            }

            canvas {
                max-width: 100%;
                background-color: var(--bg-panel);
                border: 1px solid var(--border);
                display: block;
            }

            .canvas-container {
                max-width: 100%;
                background-color: var(--bg-panel);
                border: 1px solid var(--border);
                position: relative;
                overflow: hidden;
                display: flex;
                justify-content: center;
                align-items: center;
            }

            textarea, input {
                background-color: var(--bg-panel);
                color: var(--text);
                border: 1px solid var(--border-input);
                padding: 8px;
                width: 100%;
                box-sizing: border-box;
                font-family: monospace;
            }

            .code-editor {
                height: 400px;
                background-color: var(--bg-panel);
                border: 1px solid var(--border-input);
                border-radius: 4px;
                overflow: hidden;
            }

            .code-editor textarea {
                width: 100%;
                height: 100%;
                resize: none;
                border: none;
                padding: 8px;
                background-color: transparent;
                line-height: 1.5;
                tab-size: 2;
            }

            button {
                background-color: var(--btn);
                color: var(--text);
                border: none;
                padding: 8px 16px;
                cursor: pointer;
                margin: 5px 0;
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            button:hover { background-color: var(--btn-hover); }
            button:active { transform: scale(0.98); }
            button.active { background-color: var(--btn-active); }
            button.small { padding: 4px 8px; font-size: 0.9em; }
            button.danger:hover { background-color: var(--btn-danger); color: #fff; }

            .console {
                background-color: var(--bg-console);
                color: var(--console-text);
                padding: 10px;
                font-family: monospace;
                height: 150px;
                overflow-y: auto;
                margin-top: 10px;
                white-space: pre-wrap;
                border-radius: 4px;
            }

            .control-section, .transform-controls {
                margin: 10px 0;
                padding: 10px;
                background-color: var(--bg-panel);
                border-radius: 8px;
            }

            .control-section h3 { margin-top: 0; margin-bottom: 12px; }

            .var-row {
                display: flex;
                align-items: center;
                gap: 10px;
                margin-bottom: 10px;
                flex-wrap: wrap;
            }

            .var-name { width: 150px; flex-shrink: 0; }
            .var-input { flex: 1; }

            .save-slots {
                display: flex;
                flex-wrap: wrap;
                gap: 5px;
                margin: 10px 0;
            }

            .save-slot {
                background-color: var(--btn);
                padding: 8px;
                border-radius: 4px;
                cursor: pointer;
                flex: 1;
                min-width: 80px;
                text-align: center;
                transition: all 0.2s ease;
            }

            .save-slot:hover { background-color: var(--btn-hover); }
            .save-slot:active { transform: scale(0.98); }
            .save-slot.active { background-color: var(--btn-active); }

            .warning {
                background-color: rgba(255, 200, 0, 0.2);
                color: #ffcc00;
                padding: 8px;
                margin: 5px 0;
                border-radius: 4px;
                font-size: 0.9em;
            }

            .color-preview {
                width: 20px;
                height: 20px;
                border: 1px solid var(--border-input);
                display: inline-block;
                vertical-align: middle;
                margin-left: 5px;
                border-radius: 4px;
            }

            .checkbox-wrapper {
                display: flex;
                align-items: center;
                gap: 8px;
                white-space: nowrap;
                margin-right: 15px;
            }

            .rotation-presets {
                display: flex;
                gap: 5px;
                margin-top: 5px;
                flex: 1;
            }

            .rotation-preset {
                flex: 1;
                text-align: center;
                padding: 5px;
                background-color: var(--btn);
                cursor: pointer;
                border-radius: 4px;
                transition: all 0.2s ease;
            }

            .rotation-preset:hover { background-color: var(--btn-hover); }
            .rotation-preset:active { transform: scale(0.98); }

            .history-controls { display: flex; gap: 5px; }

            .fullscreen-preview {
                position: fixed;
                top: 0;
                left: 0;
                width: 100vw;
                height: 100vh;
                background-color: rgba(0, 0, 0, 0.9);
                z-index: 1000;
                display: flex;
                justify-content: center;
                align-items: center;
                cursor: pointer;
            }

            .fullscreen-preview canvas {
                max-width: 95vw;
                max-height: 95vh;
                object-fit: contain;
            }

            .exit-fullscreen {
                position: absolute;
                top: 20px;
                right: 20px;
                background: rgba(0, 0, 0, 0.5);
                color: white;
                border: none;
                border-radius: 4px;
                padding: 10px 15px;
                cursor: pointer;
            }

            .exit-fullscreen:hover { background: rgba(30, 30, 30, 0.8); }

            .output-actions {
                display: flex;
                gap: 10px;
                padding: 10px;
                border: 1px solid var(--border);
                border-radius: 8px;
                margin: 10px 0;
            }
        </style>
    </head>
    <body>
        <div class="container">
            <h1>GLSL Image Shader</h1>

            <div class="row">
                <div class="col">
                    <h2>Input</h2>
                    <div>
                        <button id="loadImage">Load Image</button>
                        <input type="file" id="imageInput" accept="image/*" style="display: none" />
                    </div>

                    <h3>Shader Code</h3>
                    <div class="var-row">
                        <button id="loadShader">Load Shader</button>
                        <button id="saveCurrentSlot">Save Current Slot</button>
                        <button id="pauseTime">Pause Time</button>
                        <div class="history-controls">
                            <button id="undoButton" title="Undo">↩</button>
                            <button id="redoButton" title="Redo">↪</button>
                        </div>
                        <input type="file" id="shaderInput" accept=".glsl,.frag,.txt" style="display: none" />
                    </div>

                    <div class="save-slots">
                        <div class="save-slot" data-slot="1">Slot 1</div>
                        <div class="save-slot" data-slot="2">Slot 2</div>
                        <div class="save-slot" data-slot="3">Slot 3</div>
                        <div class="save-slot" data-slot="4">Slot 4</div>
                        <div class="save-slot" data-slot="5">Slot 5</div>
                    </div>

                    <div class="code-editor">
                        <textarea id="shaderCode" placeholder="Enter GLSL shader code here..."></textarea>
                    </div>
                    <button id="applyShader">Apply Shader</button>

                    <div class="control-section">
                        <h3>Canvas Settings</h3>
                        <div class="var-row">
                            <span class="var-name">Background:</span>
                            <input type="text" id="canvasBackground" value="#000000" class="var-input" placeholder="Hex color e.g. #000000" />
                            <div class="color-preview" id="bgColorPreview" style="background-color: #000000"></div>
                            <button id="applyBackground">Apply</button>
                        </div>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="transparentCanvas" />
                                <label for="transparentCanvas">Transparent Canvas</label>
                            </div>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Zoom:</span>
                            <input type="range" id="zoomLevel" min="0.1" max="5" step="0.1" value="1" class="var-input" />
                            <input type="number" id="zoomInput" value="1" min="0.1" max="5" step="0.1" style="width: 60px" />
                            <button id="resetZoom">Reset</button>
                            <span id="zoomValue">1x</span>
                        </div>
                    </div>

                    <div class="transform-controls">
                        <h3>Transform</h3>
                        <div class="var-row">
                            <span class="var-name">Canvas Position:</span>
                            <input type="number" id="canvasX" placeholder="X" min="0" class="var-input" />
                            <input type="number" id="canvasY" placeholder="Y" min="0" class="var-input" />
                            <input type="number" id="canvasWidth" placeholder="Width" min="1" class="var-input" />
                            <input type="number" id="canvasHeight" placeholder="Height" min="1" class="var-input" />
                            <button id="resetCanvas" class="small">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Aspect Ratio:</span>
                            <input type="number" id="aspectW" placeholder="Width" min="1" value="16" class="var-input" />
                            <span>:</span>
                            <input type="number" id="aspectH" placeholder="Height" min="1" value="9" class="var-input" />
                            <button id="applyAspect">Apply</button>
                            <button id="resetAspect" class="small">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Rotation:</span>
                            <div class="rotation-presets">
                                <div class="rotation-preset" data-rotation="0">0°</div>
                                <div class="rotation-preset" data-rotation="90">90°</div>
                                <div class="rotation-preset" data-rotation="180">180°</div>
                                <div class="rotation-preset" data-rotation="270">270°</div>
                            </div>
                            <button id="resetRotation" class="small">Reset</button>
                        </div>
                        <div class="var-row">
                            <span class="var-name">Mirror:</span>
                            <button id="mirrorX">X</button>
                            <button id="mirrorY">Y</button>
                            <button id="resetMirror" class="small">Reset</button>
                        </div>
                    </div>
                </div>

                <div class="col">
                    <h2>Output</h2>
                    <div class="canvas-container" id="canvasContainer">
                        <canvas id="canvas"></canvas>
                    </div>

                    <div class="output-actions">
                        <button id="fullscreenPreview">Full Screen Preview</button>
                        <button id="resetAllParams" class="danger">Reset All Parameters</button>
                    </div>

                    <div class="control-section">
                        <h3>Export Image</h3>
                        <div class="var-row">
                            <div class="checkbox-wrapper">
                                <input type="checkbox" id="exportWithAlpha" />
                                <label for="exportWithAlpha">Export with Alpha</label>
                            </div>
                        </div>
                        <div class="var-row">
                            <button id="savePNG">Save as PNG</button>
                            <button id="saveJPG">Save as JPG</button>
                        </div>
                    </div>

                    <div class="control-section">
                        <h3>Export Animation</h3>
                        <div class="var-row">
                            <span class="var-name">FPS:</span>
                            <input type="number" id="exportFps" min="1" max="60" value="30" class="var-input" />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Bitrate (Mbps):</span>
                            <input type="number" id="exportBitrate" min="1" max="50" value="5" class="var-input" />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Duration (sec):</span>
                            <input type="number" id="animationDuration" min="1" value="5" class="var-input" />
                        </div>
                        <div class="var-row">
                            <span class="var-name">Start Time (sec):</span>
                            <input type="number" id="exportStartTime" min="0" value="0" step="0.01" class="var-input" />
                        </div>
                        <div class="var-row">
                            <button id="exportMp4">Export as WebM</button>
                        </div>
                    </div>

                    <h3>Console</h3>
                    <div id="console" class="console"></div>
                </div>
            </div>
        </div>

        <div id="fullscreenContainer" style="display: none" class="fullscreen-preview">
            <canvas id="fullscreenCanvas"></canvas>
            <button class="exit-fullscreen">Exit Full Screen (ESC)</button>
            <button id="fullscreenPauseTime" class="exit-fullscreen" style="right: 180px">Pause Animation</button>
        </div>

        <script type="x-shader/x-fragment" id="defaultFragmentShader">
            precision mediump float;
            varying vec2 v_texcoord;
            uniform sampler2D tex;
            uniform float time;
            void main() {
              gl_FragColor = texture2D(tex, v_texcoord);
            }
        </script>

        <script type="x-shader/x-vertex" id="vertexShader">
            attribute vec2 a_position;
            attribute vec2 a_texcoord;
            varying vec2 v_texcoord;
            void main() {
              gl_Position = vec4(a_position, 0.0, 1.0);
              v_texcoord = a_texcoord;
            }
        </script>

        <script>
            const $ = document.getElementById.bind(document);
            const canvas = $("canvas");
            const fsCanvas = $("fullscreenCanvas");
            const canvasContainer = $("canvasContainer");
            const fsContainer = $("fullscreenContainer");
            const gl = canvas.getContext("webgl");
            let fsGl = null;
            const consoleEl = $("console");
            const codeTextarea = $("shaderCode");
            const zoomSlider = $("zoomLevel");
            const zoomInput = $("zoomInput");
            const zoomValue = $("zoomValue");
            const bgColorInput = $("canvasBackground");
            const bgColorPreview = $("bgColorPreview");
            const transCanvas = $("transparentCanvas");
            const exportAlpha = $("exportWithAlpha");

            let image = null, imageTexture = null, program = null;
            let startTime = Date.now(), pausedTime = null;
            let animFrame = null, fsAnimFrame = null;
            let posBuffer = null, texCoordBuffer = null;
            let timePaused = false, fsTimePaused = false;

            // Transform state
            let rotation = 0, mirrorX = false, mirrorY = false;
            let canvasState = { x: 0, y: 0, width: 0, height: 0 };
            let zoomLevel = 1, bgColor = "#000000";
            let useTransparent = false, useExportAlpha = false;

            // History state for undo/redo
            const maxHistory = 50;
            let history = [], historyIndex = -1;

            // Save slots
            const saveSlots = document.querySelectorAll(".save-slot");
            let activeSlot = null;

            function saveToHistory() {
                const newState = {
                    shaderCode: codeTextarea.value,
                    rotation, mirrorX, mirrorY,
                    canvas: {...canvasState},
                    bgColor, useTransparent
                };

                if (historyIndex < history.length - 1) {
                    history = history.slice(0, historyIndex + 1);
                }

                history.push(newState);
                historyIndex = history.length - 1;

                if (history.length > maxHistory) {
                    history.shift();
                    historyIndex--;
                }

                updateHistoryBtns();
            }

            function updateHistoryBtns() {
                $("undoButton").disabled = historyIndex <= 0;
                $("redoButton").disabled = historyIndex >= history.length - 1;
            }

            $("undoButton").addEventListener("click", () => {
                if (historyIndex > 0) {
                    historyIndex--;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            $("redoButton").addEventListener("click", () => {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    applyHistoryState(history[historyIndex]);
                    updateHistoryBtns();
                }
            });

            function applyHistoryState(state) {
                codeTextarea.value = state.shaderCode;
                rotation = state.rotation;
                mirrorX = state.mirrorX;
                mirrorY = state.mirrorY;
                canvasState = {...state.canvas};
                bgColor = state.bgColor;
                useTransparent = state.useTransparent;
                transCanvas.checked = useTransparent;
                bgColorInput.value = bgColor;
                bgColorPreview.style.backgroundColor = bgColor;

                updateRotationUI();
                updateCanvasUI();
                compileShader();
                updateTransform();
                updateCanvasDisplay();
            }

            // Load from localStorage
            if (localStorage.getItem("glsl-shader")) {
                codeTextarea.value = localStorage.getItem("glsl-shader");
            }

            // Initialize save slots from localStorage
            saveSlots.forEach(slot => {
                const slotNum = slot.dataset.slot;
                if (localStorage.getItem(`glsl-shader-slot-${slotNum}`)) {
                    slot.classList.add("active");
                }

                slot.addEventListener("click", () => {
                    if (slot.classList.contains("active")) {
                        // Load from slot
                        const content = localStorage.getItem(`glsl-shader-slot-${slotNum}`);
                        if (content) {
                            codeTextarea.value = content;
                            log(`Loaded shader from slot ${slotNum}`);

                            saveSlots.forEach(s => s.classList.remove("current"));
                            slot.classList.add("current");
                            activeSlot = slotNum;
                            saveToHistory();
                        }
                    } else {
                        // Save to slot
                        localStorage.setItem(`glsl-shader-slot-${slotNum}`, codeTextarea.value);
                        slot.classList.add("active");

                        saveSlots.forEach(s => s.classList.remove("current"));
                        slot.classList.add("current");
                        activeSlot = slotNum;
                        log(`Saved shader to slot ${slotNum}`);
                    }
                });

                // Right-click to clear slot
                slot.addEventListener("contextmenu", e => {
                    e.preventDefault();
                    if (confirm(`Clear save slot ${slotNum}?`)) {
                        localStorage.removeItem(`glsl-shader-slot-${slotNum}`);
                        slot.classList.remove("active");
                        slot.classList.remove("current");
                        if (activeSlot === slotNum) activeSlot = null;
                        log(`Cleared shader slot ${slotNum}`);
                    }
                });
            });

            // Zoom controls
            zoomSlider.addEventListener("input", () => {
                zoomLevel = parseFloat(zoomSlider.value);
                zoomInput.value = zoomLevel;
                zoomValue.textContent = `${zoomLevel.toFixed(1)}x`;
                updateCanvasDisplay();
            });

            zoomInput.addEventListener("input", () => {
                zoomLevel = parseFloat(zoomInput.value);
                zoomSlider.value = zoomLevel;
                zoomValue.textContent = `${zoomLevel.toFixed(1)}x`;
                updateCanvasDisplay();
            });

            $("resetZoom").addEventListener("click", () => {
                zoomLevel = 1;
                zoomSlider.value = 1;
                zoomInput.value = 1;
                zoomValue.textContent = "1x";
                updateCanvasDisplay();
            });

            // Reset all parameters
            $("resetAllParams").addEventListener("click", () => {
                // Reset transform
                rotation = 0;
                mirrorX = mirrorY = false;
                if (image) {
                    canvasState = {
                        x: 0, y: 0,
                        width: image.width,
                        height: image.height
                    };
                }

                // Reset appearance
                bgColor = "#000000";
                useTransparent = false;
                bgColorInput.value = bgColor;
                bgColorPreview.style.backgroundColor = bgColor;
                transCanvas.checked = false;

                // Reset zoom
                zoomLevel = 1;
                zoomSlider.value = 1;
                zoomInput.value = 1;
                zoomValue.textContent = "1x";

                updateRotationUI();
                updateCanvasUI();
                updateTransform();
                updateCanvasDisplay();
                saveToHistory();
                log("All parameters reset to defaults");
            });

            // Background color
            bgColorInput.addEventListener("input", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColorPreview.style.backgroundColor = color;
                }
            });

            $("applyBackground").addEventListener("click", () => {
                const color = bgColorInput.value;
                if (/^#[0-9A-F]{6}$/i.test(color)) {
                    bgColor = color;
                    updateCanvasDisplay();
                    log(`Canvas background set to ${color}`);
                    saveToHistory();
                } else {
                    log("Invalid hex color format. Use #RRGGBB format.", "error");
                }
            });

            // Transparent canvas toggle
            transCanvas.addEventListener("change", () => {
                useTransparent = transCanvas.checked;
                updateCanvasDisplay();
                render();
                saveToHistory();
            });

            // Export with alpha toggle
            exportAlpha.addEventListener("change", () => {
                useExportAlpha = exportAlpha.checked;
            });

            // Load image and shader
            $("loadImage").addEventListener("click", () => $("imageInput").click());
            $("imageInput").addEventListener("change", e => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = evt => {
                        const img = new Image();
                        img.onload = () => {
                            image = img;
                            canvas.width = img.width;
                            canvas.height = img.height;

                            canvasState = {
                                x: 0, y: 0,
                                width: img.width,
                                height: img.height
                            };
                            updateCanvasUI();
                            log(`Image loaded: ${file.name} (${img.width}x${img.height})`);

                            createImageTexture();
                            initBuffers();
                            updateCanvasDisplay();
                            startRendering();
                            saveToHistory();
                        };
                        img.src = evt.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            });

            $("loadShader").addEventListener("click", () => $("shaderInput").click());
            $("shaderInput").addEventListener("change", e => {
                if (e.target.files.length > 0) {
                    const file = e.target.files[0];
                    const reader = new FileReader();
                    reader.onload = evt => {
                        codeTextarea.value = evt.target.result;
                        log(`Shader loaded: ${file.name}`);
                        saveToHistory();
                    };
                    reader.readAsText(file);
                }
            });

            $("saveCurrentSlot").addEventListener("click", () => {
                if (activeSlot) {
                    localStorage.setItem(`glsl-shader-slot-${activeSlot}`, codeTextarea.value);
                    log(`Saved shader to slot ${activeSlot}`);
                } else {
                    localStorage.setItem("glsl-shader", codeTextarea.value);
                    log("No slot selected. Shader saved to general storage.");
                }
            });

            $("pauseTime").addEventListener("click", () => {
                timePaused = !timePaused;

                if (timePaused) {
                    pausedTime = (Date.now() - startTime) / 1000.0;
                    $("pauseTime").classList.add("active");
                    $("pauseTime").textContent = "Resume Time";
                } else {
                    pausedTime = null;
                    startTime = Date.now();
                    $("pauseTime").classList.remove("active");
                    $("pauseTime").textContent = "Pause Time";
                }

                log(`Time ${timePaused ? "paused" : "resumed"}`);
            });

            // Fullscreen pause time button
            $("fullscreenPauseTime").addEventListener("click", () => {
                fsTimePaused = !fsTimePaused;
                $("fullscreenPauseTime").textContent = fsTimePaused ? "Resume Animation" : "Pause Animation";

                if (fsGl) {
                    if (fsAnimFrame) cancelAnimationFrame(fsAnimFrame);
                    if (!fsTimePaused) {
                        animateFullscreen();
                    } else {
                        renderFullscreen();
                    }
                }
            });

            $("applyShader").addEventListener("click", () => {
                compileShader();
                render();
                saveToHistory();
            });

            $("savePNG").addEventListener("click", () => saveImage("png"));
            $("saveJPG").addEventListener("click", () => saveImage("jpeg"));
            $("exportMp4").addEventListener("click", () => exportAnimation("webm"));

            // Rotation presets
            document.querySelectorAll(".rotation-preset").forEach(preset => {
                preset.addEventListener("click", () => {
                    rotation = parseInt(preset.dataset.rotation);
                    updateRotationUI();
                    updateTransform();
                    saveToHistory();
                });
            });

            function updateRotationUI() {
                document.querySelectorAll(".rotation-preset").forEach(preset => {
                    preset.style.backgroundColor = parseInt(preset.dataset.rotation) === rotation ?
                        "var(--btn-active)" : "var(--btn)";
                });
            }

            function updateCanvasUI() {
                $("canvasX").value = canvasState.x;
                $("canvasY").value = canvasState.y;
                $("canvasWidth").value = canvasState.width;
                $("canvasHeight").value = canvasState.height;
            }

            // Reset/Mirror buttons
            $("resetRotation").addEventListener("click", () => {
                rotation = 0;
                updateRotationUI();
                updateTransform();
                saveToHistory();
            });

            $("resetMirror").addEventListener("click", () => {
                mirrorX = mirrorY = false;
                updateTransform();
                saveToHistory();
            });

            $("resetCanvas").addEventListener("click", () => {
                if (image) {
                    canvasState = { x: 0, y: 0, width: image.width, height: image.height };
                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            $("resetAspect").addEventListener("click", () => {
                $("aspectW").value = 16;
                $("aspectH").value = 9;
            });

            $("mirrorX").addEventListener("click", () => {
                mirrorX = !mirrorX;
                $("mirrorX").classList.toggle("active", mirrorX);
                updateTransform();
                saveToHistory();
            });

            $("mirrorY").addEventListener("click", () => {
                mirrorY = !mirrorY;
                $("mirrorY").classList.toggle("active", mirrorY);
                updateTransform();
                saveToHistory();
            });

            $("applyAspect").addEventListener("click", () => {
                const aspectW = parseFloat($("aspectW").value) || 16;
                const aspectH = parseFloat($("aspectH").value) || 9;

                if (image) {
                    const targetRatio = aspectW / aspectH;
                    const imgRatio = canvasState.width / canvasState.height;

                    if (imgRatio > targetRatio) {
                        // Image is wider, crop width
                        const newWidth = canvasState.height * targetRatio;
                        const deltaX = (canvasState.width - newWidth) / 2;
                        canvasState.x += deltaX;
                        canvasState.width = newWidth;
                    } else {
                        // Image is taller, crop height
                        const newHeight = canvasState.width / targetRatio;
                        const deltaY = (canvasState.height - newHeight) / 2;
                        canvasState.y += deltaY;
                        canvasState.height = newHeight;
                    }

                    updateCanvasUI();
                    updateTransform();
                    saveToHistory();
                }
            });

            // Fullscreen preview
            $("fullscreenPreview").addEventListener("click", openFullscreenPreview);

            function openFullscreenPreview() {
                if (!image) return;

                fsContainer.style.display = "flex";
                fsTimePaused = false;
                $("fullscreenPauseTime").textContent = "Pause Animation";

                fsCanvas.width = canvas.width;
                fsCanvas.height = canvas.height;

                if (!fsGl) {
                    fsGl = fsCanvas.getContext("webgl");
                    if (!fsGl) {
                        log("Failed to initialize WebGL for fullscreen preview", "error");
                        return;
                    }
                }

                setupFullscreenCanvas();
                animateFullscreen();
            }

            function animateFullscreen() {
                if (fsTimePaused) return;
                renderFullscreen();
                fsAnimFrame = requestAnimationFrame(animateFullscreen);
            }

            function setupFullscreenCanvas() {
                // Create shader program for fullscreen canvas
                const vertexShader = createShader(fsGl, fsGl.VERTEX_SHADER, $("vertexShader").textContent);
                const fragmentShader = createShader(fsGl, fsGl.FRAGMENT_SHADER, codeTextarea.value);

                if (!vertexShader || !fragmentShader) return;

                const fsProgram = createProgram(fsGl, vertexShader, fragmentShader);
                if (!fsProgram) return;

                fsGl.useProgram(fsProgram);

                // Create position buffer
                const posBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.bufferData(fsGl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), fsGl.STATIC_DRAW);

                // Apply transformed texcoords
                const texCoords = getTransformedTexCoords();
                const texBuffer = fsGl.createBuffer();
                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.bufferData(fsGl.ARRAY_BUFFER, new Float32Array(texCoords), fsGl.STATIC_DRAW);

                // Set up attributes
                const posLoc = fsGl.getAttribLocation(fsProgram, "a_position");
                const texLoc = fsGl.getAttribLocation(fsProgram, "a_texcoord");

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, posBuffer);
                fsGl.enableVertexAttribArray(posLoc);
                fsGl.vertexAttribPointer(posLoc, 2, fsGl.FLOAT, false, 0, 0);

                fsGl.bindBuffer(fsGl.ARRAY_BUFFER, texBuffer);
                fsGl.enableVertexAttribArray(texLoc);
                fsGl.vertexAttribPointer(texLoc, 2, fsGl.FLOAT, false, 0, 0);

                // Create and setup texture
                const texture = fsGl.createTexture();
                fsGl.bindTexture(fsGl.TEXTURE_2D, texture);

                fsGl.texParameteri(fsGl.TEXTURE_2D, fsGl.TEXTURE_WRAP_S, fsGl.CLAMP_TO_EDGE);
                fsGl.texParameteri(fsGl.TEXTURE_2D, fsGl.TEXTURE_WRAP_T, fsGl.CLAMP_TO_EDGE);
                fsGl.texParameteri(fsGl.TEXTURE_2D, fsGl.TEXTURE_MIN_FILTER, fsGl.LINEAR);
                fsGl.texParameteri(fsGl.TEXTURE_2D, fsGl.TEXTURE_MAG_FILTER, fsGl.LINEAR);

                fsGl.texImage2D(fsGl.TEXTURE_2D, 0, fsGl.RGBA, fsGl.RGBA, fsGl.UNSIGNED_BYTE, image);

                // Set uniforms
                const texUnitLoc = fsGl.getUniformLocation(fsProgram, "tex");
                fsGl.uniform1i(texUnitLoc, 0);

                const timeLoc = fsGl.getUniformLocation(fsProgram, "time");
                if (timeLoc) {
                    if (timePaused && pausedTime !== null) {
                        fsGl.uniform1f(timeLoc, pausedTime);
                    } else {
                        fsGl.uniform1f(timeLoc, (Date.now() - startTime) / 1000.0);
                    }
                }
            }

            function renderFullscreen() {
                if (!fsGl) return;

                fsGl.viewport(0, 0, fsCanvas.width, fsCanvas.height);

                // Parse background color
                let r = 0, g = 0, b = 0, a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }

                fsGl.clearColor(r, g, b, a);
                fsGl.clear(fsGl.COLOR_BUFFER_BIT);

                // Update time uniform
                const program = fsGl.getParameter(fsGl.CURRENT_PROGRAM);
                const timeLoc = fsGl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (fsTimePaused) {
                        const currentTime = fsGl.getUniform(program, timeLoc);
                        fsGl.uniform1f(timeLoc, currentTime);
                    } else if (timePaused && pausedTime !== null) {
                        fsGl.uniform1f(timeLoc, pausedTime);
                    } else {
                        fsGl.uniform1f(timeLoc, (Date.now() - startTime) / 1000.0);
                    }
                }

                fsGl.drawArrays(fsGl.TRIANGLE_STRIP, 0, 4);
            }

            function closeFullscreenPreview() {
                fsContainer.style.display = "none";
                if (fsAnimFrame) {
                    cancelAnimationFrame(fsAnimFrame);
                    fsAnimFrame = null;
                }
            }

            // Exit fullscreen on button click or ESC key
            document.querySelector(".exit-fullscreen").addEventListener("click", closeFullscreenPreview);
            fsContainer.addEventListener("click", e => {
                if (e.target === fsContainer) closeFullscreenPreview();
            });

            document.addEventListener("keydown", e => {
                if (e.key === "Escape" && fsContainer.style.display !== "none") {
                    closeFullscreenPreview();
                }
            });

            // Monitor canvas input changes
            ["canvasX", "canvasY", "canvasWidth", "canvasHeight"].forEach(id => {
                $(id).addEventListener("change", () => {
                    canvasState.x = parseFloat($("canvasX").value) || 0;
                    canvasState.y = parseFloat($("canvasY").value) || 0;
                    canvasState.width = parseFloat($("canvasWidth").value) || image?.width || 0;
                    canvasState.height = parseFloat($("canvasHeight").value) || image?.height || 0;
                    updateTransform();
                    saveToHistory();
                });
            });

            // WebGL setup
            if (!gl) {
                log("WebGL not supported!", "error");
            } else {
                log("WebGL initialized successfully");
                initWebGL();
            }

            function initWebGL() {
                const vertexShader = createShader(gl, gl.VERTEX_SHADER, $("vertexShader").textContent);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, $("defaultFragmentShader").textContent);
                program = createProgram(gl, vertexShader, fragmentShader);
                initBuffers();
                saveToHistory();
            }

            function initBuffers() {
                // Position buffer
                posBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([-1, -1, 1, -1, -1, 1, 1, 1]), gl.STATIC_DRAW);

                // Texture coordinates buffer
                texCoordBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([0, 1, 1, 1, 0, 0, 1, 0]), gl.STATIC_DRAW);
            }

            function getTransformedTexCoords() {
                let texCoords;

                // Optimized presets for 90-degree rotations
                switch (rotation % 360) {
                    case 0: texCoords = [0, 1, 1, 1, 0, 0, 1, 0]; break;
                    case 90: texCoords = [0, 0, 0, 1, 1, 0, 1, 1]; break;
                    case 180: texCoords = [1, 0, 0, 0, 1, 1, 0, 1]; break;
                    case 270: texCoords = [1, 1, 1, 0, 0, 1, 0, 0]; break;
                    default: texCoords = [0, 1, 1, 1, 0, 0, 1, 0];
                }

                // Apply mirroring
                if (mirrorX) {
                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }

                if (mirrorY) {
                    for (let i = 1; i < texCoords.length; i += 2) {
                        texCoords[i] = 1 - texCoords[i];
                    }
                }

                // Apply canvas position
                if (image && image.width > 0 && image.height > 0) {
                    const xScale = canvasState.width / image.width;
                    const yScale = canvasState.height / image.height;
                    const xOffset = canvasState.x / image.width;
                    const yOffset = canvasState.y / image.height;

                    for (let i = 0; i < texCoords.length; i += 2) {
                        texCoords[i] = texCoords[i] * xScale + xOffset;
                        texCoords[i + 1] = texCoords[i + 1] * yScale + yOffset;
                    }
                }

                return texCoords;
            }

            function createShader(ctx, type, source) {
                const shader = ctx.createShader(type);
                ctx.shaderSource(shader, source);
                ctx.compileShader(shader);

                if (!ctx.getShaderParameter(shader, ctx.COMPILE_STATUS)) {
                    log(`Error compiling shader: ${ctx.getShaderInfoLog(shader)}`, "error");
                    ctx.deleteShader(shader);
                    return null;
                }

                return shader;
            }

            function createProgram(ctx, vertexShader, fragmentShader) {
                const prog = ctx.createProgram();
                ctx.attachShader(prog, vertexShader);
                ctx.attachShader(prog, fragmentShader);
                ctx.linkProgram(prog);

                if (!ctx.getProgramParameter(prog, ctx.LINK_STATUS)) {
                    log(`Error linking program: ${ctx.getProgramInfoLog(prog)}`, "error");
                    ctx.deleteProgram(prog);
                    return null;
                }

                return prog;
            }

            function createImageTexture() {
                if (!image) return;

                if (imageTexture) gl.deleteTexture(imageTexture);

                imageTexture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);

                canvas.width = image.width;
                canvas.height = image.height;

                canvasState = { x: 0, y: 0, width: image.width, height: image.height };
            }

            function compileShader() {
                const fragmentSource = codeTextarea.value.trim();
                if (!fragmentSource) {
                    log("Shader code is empty!", "error");
                    return;
                }

                const vertexShader = createShader(gl, gl.VERTEX_SHADER, $("vertexShader").textContent);
                const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentSource);
                if (!fragmentShader) return;

                const newProgram = createProgram(gl, vertexShader, fragmentShader);
                if (!newProgram) return;

                if (program) gl.deleteProgram(program);
                program = newProgram;
                gl.useProgram(program);

                log("Shader compiled successfully");

                // Reset time
                startTime = Date.now();
                pausedTime = null;
                timePaused = false;
                $("pauseTime").classList.remove("active");
                $("pauseTime").textContent = "Pause Time";
            }

            function updateTransform() {
                if (!image) return;

                // Set canvas dimensions based on rotation
                if (rotation % 180 === 90) {
                    canvas.width = canvasState.height;
                    canvas.height = canvasState.width;
                } else {
                    canvas.width = canvasState.width;
                    canvas.height = canvasState.height;
                }

                // Update texture coordinates
                const texCoords = getTransformedTexCoords();
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(texCoords), gl.STATIC_DRAW);

                // Update UI
                $("mirrorX").classList.toggle("active", mirrorX);
                $("mirrorY").classList.toggle("active", mirrorY);

                updateCanvasDisplay();
                render();
                log(`Transform updated: rotation=${rotation}°, mirrorX=${mirrorX}, mirrorY=${mirrorY}, canvas=(${canvasState.x},${canvasState.y},${canvasState.width},${canvasState.height})`);
            }

            function updateCanvasDisplay() {
                if (useTransparent) {
                    canvasContainer.style.backgroundColor = "transparent";
                    canvasContainer.style.backgroundImage =
                        "linear-gradient(45deg, #aaa 25%, transparent 25%), " +
                        "linear-gradient(-45deg, #aaa 25%, transparent 25%), " +
                        "linear-gradient(45deg, transparent 75%, #aaa 75%), " +
                        "linear-gradient(-45deg, transparent 75%, #aaa 75%)";
                    canvasContainer.style.backgroundSize = "20px 20px";
                    canvasContainer.style.backgroundPosition = "0 0, 0 10px, 10px -10px, -10px 0px";
                } else {
                    canvasContainer.style.backgroundColor = bgColor;
                    canvasContainer.style.backgroundImage = "none";
                }

                canvas.style.transformOrigin = "center center";
                canvas.style.transform = `scale(${zoomLevel})`;
            }

            function startRendering() {
                if (animFrame) cancelAnimationFrame(animFrame);

                function animate() {
                    render();
                    animFrame = requestAnimationFrame(animate);
                }

                animate();
            }

            function stopRendering() {
                if (animFrame) {
                    cancelAnimationFrame(animFrame);
                    animFrame = null;
                }
            }

            function render() {
                if (!gl || !program || !imageTexture) return;

                gl.viewport(0, 0, canvas.width, canvas.height);

                // Set clear color
                let r = 0, g = 0, b = 0, a = useTransparent ? 0 : 1;
                if (!useTransparent && /^#[0-9A-F]{6}$/i.test(bgColor)) {
                    const hex = bgColor.substring(1);
                    r = parseInt(hex.substring(0, 2), 16) / 255;
                    g = parseInt(hex.substring(2, 4), 16) / 255;
                    b = parseInt(hex.substring(4, 6), 16) / 255;
                }

                gl.clearColor(r, g, b, a);
                gl.clear(gl.COLOR_BUFFER_BIT);

                gl.useProgram(program);

                // Bind position buffer
                const posLoc = gl.getAttribLocation(program, "a_position");
                gl.bindBuffer(gl.ARRAY_BUFFER, posBuffer);
                gl.enableVertexAttribArray(posLoc);
                gl.vertexAttribPointer(posLoc, 2, gl.FLOAT, false, 0, 0);

                // Bind texture coordinates
                const texLoc = gl.getAttribLocation(program, "a_texcoord");
                gl.bindBuffer(gl.ARRAY_BUFFER, texCoordBuffer);
                gl.enableVertexAttribArray(texLoc);
                gl.vertexAttribPointer(texLoc, 2, gl.FLOAT, false, 0, 0);

                // Set texture
                const texLocation = gl.getUniformLocation(program, "tex");
                gl.uniform1i(texLocation, 0);
                gl.activeTexture(gl.TEXTURE0);
                gl.bindTexture(gl.TEXTURE_2D, imageTexture);

                // Set time uniform
                const timeLoc = gl.getUniformLocation(program, "time");
                if (timeLoc) {
                    if (timePaused && pausedTime !== null) {
                        gl.uniform1f(timeLoc, pausedTime);
                    } else {
                        gl.uniform1f(timeLoc, (Date.now() - startTime) / 1000.0);
                    }
                }

                // Handle transparency
                if (useTransparent) {
                    gl.enable(gl.BLEND);
                    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
                } else {
                    gl.disable(gl.BLEND);
                }

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }

            function saveImage(type) {
                if (!canvas) return;

                try {
                    render();
                    gl.finish();

                    const mimeType = type === "png" ? "image/png" : "image/jpeg";
                    const quality = type === "png" ? undefined : 0.9;

                    const tempCanvas = document.createElement("canvas");
                    tempCanvas.width = canvas.width;
                    tempCanvas.height = canvas.height;
                    const tempCtx = tempCanvas.getContext("2d", { alpha: useExportAlpha });

                    if (!useExportAlpha) {
                        tempCtx.fillStyle = bgColor;
                        tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);
                    }

                    tempCtx.drawImage(canvas, 0, 0);

                    const imageData = tempCanvas.toDataURL(mimeType, quality);

                    const link = document.createElement("a");
                    link.download = `shader_output.${type === "png" ? "png" : "jpg"}`;
                    link.href = imageData;
                    link.click();

                    log(`Image saved as ${type.toUpperCase()}`);
                } catch (error) {
                    log(`Error saving image: ${error}`, "error");
                }
            }

            function exportAnimation(type) {
                if (!canvas) {
                    log("No canvas to export!", "error");
                    return;
                }

                if (type === "webm") {
                    try {
                        const duration = parseFloat($("animationDuration").value) || 5;
                        const fps = parseInt($("exportFps").value) || 30;
                        const startTime = parseFloat($("exportStartTime").value) || 0;
                        const bitrate = parseInt($("exportBitrate").value) || 5;

                        log(`Starting animation export: ${duration * fps} frames at ${fps} fps, starting at ${startTime}s...`);

                        timePaused = true;
                        pausedTime = startTime;

                        const stream = canvas.captureStream(fps);
                        const recorder = new MediaRecorder(stream, {
                            mimeType: "video/webm",
                            videoBitsPerSecond: bitrate * 1000000
                        });

                        const chunks = [];
                        recorder.ondataavailable = e => chunks.push(e.data);
                        recorder.onstop = () => {
                            const blob = new Blob(chunks, { type: "video/webm" });
                            const url = URL.createObjectURL(blob);

                            const link = document.createElement("a");
                            link.href = url;
                            link.download = "shader_animation.webm";
                            link.click();

                            log("Animation exported as WebM");
                            log(`Download links: [WebM](${url})`);

                            timePaused = false;
                            startTime = Date.now();
                            log("Export complete!");
                        };

                        recorder.start();

                        let currentTime = startTime;
                        const endTime = startTime + duration;
                        const frameInterval = 1000 / fps;

                        function renderFrame() {
                            if (currentTime >= endTime) {
                                recorder.stop();
                                return;
                            }

                            pausedTime = currentTime;
                            render();
                            currentTime += frameInterval / 1000;
                            setTimeout(renderFrame, frameInterval);
                        }

                        renderFrame();
                    } catch (error) {
                        log(`Error exporting animation: ${error}`, "error");
                        timePaused = false;
                    }
                }
            }

            function log(message, type = "info") {
                const timestamp = new Date().toLocaleTimeString();
                const formatted = `[${timestamp}] [${type.toUpperCase()}] ${message}`;

                console[type === "error" ? "error" : "log"](message);

                consoleEl.innerHTML += formatted + "\n";
                consoleEl.scrollTop = consoleEl.scrollHeight;
            }

            // Start rendering
            startRendering();

            // Initial UI setup
            updateRotationUI();
            updateHistoryBtns();
        </script>
    </body>
</html>
